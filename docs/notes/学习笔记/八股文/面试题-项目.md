## 智慧教育系统

### 你在“智慧教育系统”中提到了 ClickHouse 的使用，能详细讲讲你是如何提升查询性能的吗？有哪些具体优化手段？

原本学生行为数据存储在 Hadoop + Hive 中，面对复杂画像查询时性能瓶颈明显，甚至几十秒以上。尝试 Spark on Hive 后因兼容性和部署成本放弃。

最终我主导将数据迁移至 ClickHouse，主要优化点有：

1. **按学年、学院等维度设计分区键**，结合 MergeTree 引擎，大幅减少扫描范围；
2. 采用 **宽表模型+列式存储**，一次查询命中多个标签字段，降低关联开销；
3. 接入 **Redis 缓存热点查询**结果，并通过参数控制缓存过期时间；
4. 在接口层封装 SQL 构造器，支持按条件灵活组合维度并安全拼接 SQL，防止注入。

最终将原查询时间从几十秒压缩至 100ms 以内，满足了实时画像与动态分群的业务需求。

### 你在项目中设计并实现了“基于注解 + AOP + 数据库”的数据权限控制系统，请详细讲讲设计思路，怎么做到“业务代码零侵入”？

> 我在项目中设计了基于注解 + AOP 的数据权限框架，目标是实现“零侵入”的数据访问控制。整体流程如下：
>
> 1. **权限模型设计**：在数据库中定义权限维度（全部、本部门、本人、自定义），用户与角色关联，角色对应不同的数据访问规则。
> 2. **自定义注解 `@DataScope`**：用于标注需要数据权限控制的方法，并配置控制维度字段（如部门ID字段、用户ID字段）；
> 3. **AOP 切面处理**：在方法执行前，解析注解，获取当前用户的角色信息，然后在 MyBatis 的查询条件中**动态注入数据范围 SQL 片段**（如 `AND dept_id IN (...)`），从源头限制查询数据；
> 4. **SQL 拼接安全性**：所有 SQL 条件拼接使用参数绑定避免注入风险，注解参数控制是否启用数据权限；
> 5. **业务无感知**：控制逻辑集中在 AOP 层，业务代码无需关心数据范围，保证模块解耦。
>
> 举例：查询学生数据时，拥有“本部门数据”权限的用户只会查到其所在学院的学生记录。

> 最终实现了按用户、角色、部门多个维度精细化控制，同时兼顾安全性与可维护性。

### 你在“智慧教育系统”中提到了微服务架构，假如让你从零开始设计这样一个系统，请问你会如何划分微服务？服务之间如何通信？如何保证系统的稳定性与扩展性？

智慧教育系统采用微服务架构，我们从**领域驱动设计**出发，结合实际九大职责与十大育人模块进行模块拆分。服务大致包括：

- **用户服务**：统一身份认证（SSO）、学生/教师基本信息管理
- **权限服务**：基于角色的数据访问控制（集成 Shiro）
- **工作流服务**：基于 Activiti 处理审批流配置与节点执行
- **画像服务**：处理标签建模、分群逻辑与行为采集分析
- **文件服务**：提供统一上传、预览、存储管理（基于 MinIO）
- **九大职责服务**：分别对应辅导员日常工作的各个子系统
- **网关服务**：统一入口，负责路由、鉴权、限流等

### 你提到在项目中处理过缓存穿透、缓存雪崩等问题，请你详细讲讲这两种问题是怎么发生的，你是如何应对和优化的？

在实际项目中，我们遇到了 **缓存穿透** 和 **缓存雪崩** 两类问题，分别是这样应对的：

**一、缓存穿透：**

- 问题背景：某些画像在测试后被老师删除，数据库和 Redis 都无记录，但页面未刷新，导致不断请求该画像 ID，频繁打到数据库；
- 处理措施：
  1. 查询数据库返回 `null` 时，也将该空值缓存（短 TTL，如 2 分钟）；
  2. 后续补充了用户行为限流 + 布隆过滤器，用于快速判断 ID 是否存在；

**二、缓存雪崩：**

- 问题背景：Redis 单节点宕机，正值毕业季高峰，大量请求击穿缓存直接压垮数据库；
- 处理措施：
  1. 排查并恢复 Redis 服务器；
  2. 后续上线 Redis Cluster，实现多节点主从 + 哨兵故障转移；
  3. 设置热点 Key 过期时间随机化（TTL 加随机数）避免同一时间大量缓存失效；
  4. 引入限流与降级机制，防止高并发直接打穿数据库；

### 你在简历中提到了“数据库建模、索引优化、SQL 调优”的经验，能不能举一个你实际优化 SQL 性能的例子？你是怎么定位问题、如何优化的？

在智慧教育系统中，学生表是访问最频繁的表之一，尤其是通过学号查询单个学生信息。在使用过程中我们发现：

- 某些查询语句响应时间超过 1 秒，影响用户体验；
- 使用 `EXPLAIN` 分析发现，原语句未走索引，采用的是全表扫描（type = ALL）；

**优化过程如下：**

1. 在 `stu_number`（学号）字段上建立 **唯一索引**，因为学号是唯一且高频检索字段；
2. 为一些复杂查询创建了 **覆盖索引**（如联合索引 `(stu_number, status)`），避免回表；
3. 为按时间范围查询的数据添加 **组合索引+分区表设计**，提升批量处理效率；
4. 优化后的查询 `type` 显示为 `const` 或 `ref`，**响应时间从秒级降至毫秒级**；

此外，我们还建立了慢查询日志定期分析机制，结合 SQL 审核工具（如 SQLAdvisor）进行持续优化。

### 你在智慧教育系统中使用了 Activiti 工作流，请问你是如何设计和使用它的？怎么实现流程的灵活配置而不修改代码？

在智慧教育系统中，我们使用 Activiti 实现审批流管理，目标是支持不同业务模块灵活配置流程、动态绑定、无需改动代码。整体设计如下：

**1. 前端建模：**

- 前端通过可视化建模工具（如 Flowable Editor）创建流程图，可设置流程节点、审批人、条件表达式等；
- 完成后导出 BPMN 文件，上传至后端；

**2. 流程部署与绑定：**

- 后端使用 Activiti 的 `RepositoryService` 动态部署 BPMN 文件；
- 使用枚举类标识业务类型（如“请假流程”、“画像审批”），流程定义与业务表通过 `businessKey` 绑定；

**3. 动态流程启动与控制：**

- 业务调用 `RuntimeService.startProcessInstanceByKey()` 启动流程；
- 使用流程变量传递审批人、条件数据，控制流程分支；
- 每个节点完成后触发监听器，调用业务逻辑（如状态变更、通知等）；

**4. 可扩展设计：**

- BPMN 模型和审批人等配置均持久化至数据库，支持业务侧配置无需改动流程图；
- 异常节点支持挂起、恢复、跳转，保障流程可靠性；

最终实现了**流程与业务解耦、按需配置、快速响应业务变更**的目标。

### 你提到“封装了 MyBatis-Plus 通用接口组件，统一开发规范”，请具体讲讲这个组件是怎么设计的？封装了哪些功能？怎么提升了团队协同效率？

当时是由于系统上各种表的CRUD太多，代码过于重复，导致开发效率低下。于是我想到了封装MyBatis-Plus的方法，最开始只是设置了BaseController和BaseService，这样只需要业务表的Controller继承自BaseController就能够自动拥有增删改查的接口，但后来发现这样会导致类爆炸的问题，业务表太多导致Controller过多。于是我设计了动态代理的方式去动态生成Controller并注册到Spring Mapper中，具体实现流程是这样的，首先设计一个AutoApi的注解，注解可以指定path路径，动态代理类实现了Spring的监听接口，在Spring广播了上下文刷新事件后进行执行，这个时候Spring的Bean都已经准备好了。我通过扫描基础包，去获取带了AutoApi注解的实体类，然后通过ByteBuddy去动态创建一个AutoApiController类继承BaseController，通过服务发现和反射机制注入Service和entity，然后添加到Spring的Bean容器中，最后通过反射调用SpringMVC的detectHandlerMethods方法，将将Controller方法注册为 Handler，映射到 Spring MVC 的 HandlerMapping 中。从而实现了只需要在实体类上加一个AutoApi注解，即可自动产生RESTful API的功能。另外我还封装了统一的分页管理器，以及统一的响应包，统一的异常处理。大大提高了团队开发效率。

## MyBatis-Plus-Kit

### 这个组件是如何实现自动生成接口的

> 首先动态代理类实现`ApplicationListener<ContextRefreshedEvent>`监听上下文刷新事件，使得动态代理在Spring容器准备完成后开始执行。

1. 在指定的basePackage中扫描所有带AutoApi注解的实体类，且mode为Proxy，作为接口生成的目标对象。
2. 使用ByteBuddy动态创建RestController类：①继承BaseController获得CRUD能力；②添加@RestController和@RequestMapping注解。③动态生成类名：AutoApi{EntityName}Controller
3. 通过服务发现和反射机制注入Service类和实体类，并将实例注册为Spring单例Bean。
4. 手动调用Spring MVC的内部方法detectHandlerMethods，使动态生成的控制器能处理Http请求。

我开发的 MyBatis-Plus-Kit 组件中，提供了一个 `@AutoApi` 注解驱动的能力，可以实现对实体类自动生成并注册对应的API接口。这个能力的核心是动态生成 Controller 类并将其注册到 Spring MVC 的映射机制中。我阅读了 SpringMVC 的源码，了解到 `RequestMappingHandlerMapping` 是核心的 Handler 注册组件，其 `detectHandlerMethods()` 方法负责扫描 Bean 中的 `@RequestMapping` 方法并建立URL到方法的映射。因此我实现了一个 `ApplicationListener<ContextRefreshedEvent>` 接口，在 Spring 容器启动完成后，通过 `ClassPathScanningCandidateComponentProvider` 扫描带有 `@AutoApi` 注解的实体类。在匹配到注解且符合 PROXY 模式的前提下，我使用 ByteBuddy 动态生成一个继承自 BaseController 的类，并在类上加上 `@RestController` 与 `@RequestMapping` 注解。随后，我通过 Spring 的 `DefaultListableBeanFactory` 将这个类注册为一个 Singleton Bean，并通过反射注入对应的 Service 实例和实体类的 `Class` 类型。同时，为了让 Spring MVC 感知这个运行时注册的 Controller，我反射调用了 `AbstractHandlerMethodMapping.detectHandlerMethods()` 方法手动触发 URL 映射建立。这样，整个流程无需开发者手动写 Controller，只需在实体类上加注解即可生成完整的 API。我还设计了一个 `ServiceResolver` 工具类，支持按命名约定或注解参数解析 Service，提升了兼容性和可维护性。整个实现过程中涉及对 Spring Bean 生命周期、Spring MVC 映射机制、ByteBuddy 字节码生成技术的深入理解与综合运用，实现了低侵入、高扩展的自动 API 注册机制。这个设计目标是为了让 MyBatis-Plus 更加工程化、开箱即用，简化后端接口开发的重复工作。

### 你觉得你的设计还有什么问题吗

1. 由于是动态注册的Bean，所以可能会导致调试困难。
2. 由于Spring生命周期的问题，可能会导致AOP切面不生效，

> Spring生命周期：
>
> 1. BeanDefinition加载阶段：包扫描、注解处理、创建BeanDefinition
> 2. Bean实例化阶段：创建Bean实例，并注入依赖（构造函数、@Autowired）
> 3. Bean初始化阶段：执行 `InitializingBean.afterPropertiesSet()`、`@PostConstruct`
> 4. 容器刷新阶段：`ApplicationContext` 执行 `refresh()`，初始化 Web 框架核心组件（如 DispatcherServlet、HandlerMapping）
> 5. 事件广播阶段：广播 `ContextRefreshedEvent`
> 6. 容器就绪阶段