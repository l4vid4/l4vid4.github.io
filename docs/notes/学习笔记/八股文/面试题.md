# 第一章-Java基础

## 1、你是怎样理解OOP面向对象

面向对象是利用语言对现实事物进行抽象。面向对象具有以下特征：

1. 继承：继承是从已有类得到继承信息创建新类的过程
2. 封装：封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口
3. 多态：多态是指允许不同子类型的对象对同一消息作出不同的响应

## 2、重载和重写的区别

1. 重载发生在本类，重写发生在父类与子类之间
2. 重载的方法名必须相同，重写的方法名相同且返回值类型必须相同。
3. 重载的参数列表不同，重写的参数列表必须相同
4. 重写的访问权限不能比父类中被重写的方法的访问权限更低。
5. 构造方法不能被重写

## 3、接口与抽象类的区别

1. 抽象类要被子类继承，接口要被类实现
2. 接口可多继承接口，但类只单继承
3. 抽象类可以有构造器、接口不能有构造器
4. 抽象类：除了不能实例化抽象类之外，它和普通Java类没有任何区别
5. 抽象类抽象方法可以有public、protected和default这些修饰符、接口：只能是public
6. 抽象类：可以有成员变量；接口：只能声明常量

## 4、深拷贝与浅拷贝的理解

深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用。

1. 浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象
2. 深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的类指向的不是同一个对象。

- 浅拷贝实现方式

>  直接**.clone()**即可，也可以实现 `Cloneable` 接口并简单重写 `clone()` 方法

- 深拷贝实现方式

> 1. 重写`clone()`方法后，手动实现深拷贝
> 2. 通过序列化反序列化来实现深拷贝
> 3. 使用 `copy` 工具类（如 Apache Commons Lang 的 `SerializationUtils`）

## 5、sleep和wait区别

| **方法**  | **定义**                                                     | **常见用途**                   |
| --------- | ------------------------------------------------------------ | ------------------------------ |
| `wait()`  | 释放锁并进入等待状态，直到被其他线程 `notify()` 或 `notifyAll()` 唤醒 | 线程间协作，等待某个条件的发生 |
| `sleep()` | 暂停当前线程一段时间，但不释放锁                             | 模拟延迟，控制线程执行节奏     |

### 主要区别

| **特性**     | **`wait()`**                           | **`sleep()`**                 |
| ------------ | -------------------------------------- | ----------------------------- |
| **锁释放**   | 释放当前对象锁                         | 不释放锁                      |
| **调用位置** | 必须在同步块 (`synchronized`) 中调用   | 可以在任何地方调用            |
| **所属类**   | `Object` 类                            | `Thread` 类                   |
| **中断行为** | 会抛出 `InterruptedException`          | 会抛出 `InterruptedException` |
| **唤醒机制** | 需要 `notify()` 或 `notifyAll()`       | 自动恢复，无需唤醒            |
| **状态**     | 进入 `WAITING` 或 `TIMED_WAITING` 状态 | 进入 `TIMED_WAITING` 状态     |

- sleep方法

> 属于Thread类中的方法，释放cpu给其它线程，不释放锁资源。
>
> `sleep(1000)`等待1s被唤醒
>
> ```java
> public class SleepDemo {
>     public static void main(String[] args) throws InterruptedException {
>         Thread t1 = new Thread(() -> {
>             try {
>                 System.out.println("Thread 1 sleeping...");
>                 Thread.sleep(2000);
>                 System.out.println("Thread 1 woke up!");
>             } catch (InterruptedException e) {
>                 e.printStackTrace();
>             }
>         });
> 
>         Thread t2 = new Thread(() -> {
>             try {
>                 System.out.println("Thread 2 sleeping...");
>                 Thread.sleep(1000);
>                 System.out.println("Thread 2 woke up!");
>             } catch (InterruptedException e) {
>                 e.printStackTrace();
>             }
>         });
> 
>         t1.start();
>         t2.start();
>     }
> }
> 
> ```
>
> 

- wait方法

> 属于Object类中的方法，释放cpu给其它线程，同时释放锁资源。
>
> `wait(1000)`等待超过1s被唤醒，
>
> `wait()`一直等待需要通过notify或者notifyAll进行唤醒
>
> wait方法必须配合synchronized一起使用，不然在运行时就会抛出IllegalMonitorStateException异常
>
> ```java
> class Counter {
>     private int count = 0;
> 
>     public synchronized void increment() throws InterruptedException {
>         while (count >= 1) {
>             System.out.println(Thread.currentThread().getName() + " waiting...");
>             wait();  // 释放锁并等待
>         }
>         count++;
>         System.out.println(Thread.currentThread().getName() + " incremented: " + count);
>         notify();  // 唤醒其他等待的线程
>     }
> 
>     public synchronized void decrement() throws InterruptedException {
>         while (count == 0) {
>             System.out.println(Thread.currentThread().getName() + " waiting...");
>             wait();  // 释放锁并等待
>         }
>         count--;
>         System.out.println(Thread.currentThread().getName() + " decremented: " + count);
>         notify();  // 唤醒其他等待的线程
>     }
> }
> 
> public class WaitDemo {
>     public static void main(String[] args) {
>         Counter counter = new Counter();
> 
>         Thread t1 = new Thread(() -> {
>             try {
>                 counter.increment();
>             } catch (InterruptedException e) {
>                 e.printStackTrace();
>             }
>         }, "Incrementer");
> 
>         Thread t2 = new Thread(() -> {
>             try {
>                 counter.decrement();
>             } catch (InterruptedException e) {
>                 e.printStackTrace();
>             }
>         }, "Decrementer");
> 
>         t1.start();
>         t2.start();
>     }
> }
> 
> ```

## 6、什么是自动拆装箱，int和Integer有什么区别

### 自动拆装箱

**自动装箱（Autoboxing）** 和 **自动拆箱（Unboxing）** 是 Java 为了简化基本类型和包装类型之间的转换而引入的机制。java为什么要引入自动装箱和拆箱的功能？主要是用于java集合中，`List<Inteter> list=new ArrayList<Integer>();`list集合如果要放整数的话，只能放对象，不能放基本类型，因此需要将整数自动装箱成对象。

- **自动装箱（Autoboxing）**：将 **基本类型** 转换为 **对应的包装类型**。`int primitiveInt = 10;  Integer wrappedInt = primitiveInt;`

- **自动拆箱（Unboxing）**：将 **包装类型** 转换为 **对应的基本类型**。`Integer wrappedInt = 20; int primitiveInt = wrappedInt;`

### int和Integer的区别

| **特性**     | **int**         | **Integer**                                 |
| ------------ | --------------- | ------------------------------------------- |
| **类型**     | 基本数据类型    | 包装类（`java.lang.Integer`）               |
| **内存分配** | 栈内存          | 堆内存                                      |
| **初始值**   | 0               | `null`                                      |
| **存储范围** | -2^31 到 2^31-1 | -2^31 到 2^31-1                             |
| **性能**     | 更高            | 较低                                        |
| **方法**     | 无              | 包含常用方法，如 `parseInt()`、`toString()` |
| **比较**     | `==` 比较值     | `==` 比较引用，`.equals()` 比较值           |

### Integer缓存机制

`Integer` 在 **-128 到 127** 之间的值会 **缓存**，在这个范围内的 `Integer` 对象会复用已有实例，超出这个范围的值则会创建新的实例。

## 7、==和equals区别

| **特性**       | **`==`**                           | **`equals()`**                           |
| -------------- | ---------------------------------- | ---------------------------------------- |
| **比较内容**   | 比较**引用地址**（基本类型比较值） | 默认比较**引用地址**，可重写后比较**值** |
| **适用类型**   | 基本数据类型和引用类型             | 仅适用于引用类型                         |
| **性能**       | 更快                               | 较慢（涉及方法调用）                     |
| **可重写性**   | 不可重写                           | 可在类中重写                             |
| **空指针安全** | 安全                               | 可能抛出 `NullPointerException`          |

### String特殊情况

- 虽然 **`String` 是引用类型**，但在某些情况下可以直接使用 **`==`** 进行比较，这是因为 **`String` 具有常量池机制**。但String还是建议使用`.equals()`去比较字符串，也可使用`Objects.equals()`避免空指针异常。

  > **String 常量池**（String Constant Pool）是 Java 在方法区（JDK 7+ 是堆）中专门为字符串优化的内存区域。
  >
  > **主要特点：**
  >
  > - **相同内容的字符串只存储一份**，节省内存。
  > - **编译时确定**的字符串会自动放入常量池。
  > - **运行时**可以手动将字符串添加到常量池中。
  >
  > ```java
  > public class StringPoolExample {
  >     public static void main(String[] args) {
  >         String s1 = "hello";       // 存入常量池
  >         String s2 = "hello";       // 复用常量池中的 "hello"
  >         String s3 = new String("hello");  // 创建新对象，不在常量池
  >         String s4 = s3.intern();   // 将 s3 放入常量池
  > 
  >         System.out.println(s1 == s2);  // true, 指向常量池同一地址
  >         System.out.println(s1 == s3);  // false, 不同引用
  >         System.out.println(s1 == s4);  // true, intern() 返回常量池中的引用
  >     }
  > }
  > ```

## 8、String能被继承吗？为什么使用final修饰

- String不能被继承，因为它是一个final修饰的类

### 为什么String被final修饰

1. 保证字符串的不可变性
2. 提高字符串常量池的效率
3. String 类中有native关键字修饰的调用系统级别的本地方法，调用了操作系统的 API，如果方法可以重写，可能被植入恶意代码，破坏程序。Java 的安全性也体现在这里。

## 9、StringBuffer和StringBuilder的区别

| **特性**       | **`StringBuffer`**                              | **`StringBuilder`**                             |
| -------------- | ----------------------------------------------- | ----------------------------------------------- |
| **线程安全性** | 线程安全（方法同步）                            | 非线程安全                                      |
| **性能**       | 较慢（同步开销）                                | 较快                                            |
| **适用场景**   | 多线程环境                                      | 单线程环境                                      |
| **初始版本**   | JDK 1.0                                         | JDK 1.5                                         |
| **常用方法**   | `append()`, `insert()`, `delete()`, `reverse()` | `append()`, `insert()`, `delete()`, `reverse()` |
| **是否可变**   | 可变                                            | 可变                                            |

## 10、final、finally、finalize？

- **final：**修饰符（关键字）有三种用法：修饰类、变量和方法。修饰类时，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中只能读取不可修改，即为常量。修饰方法时，也同样只能使用，不能在子类中被重写。

- **finally：**通常放在try…catch的后面构造最终执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。

- **finalize：**Object类中定义的方法，Java中允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize() 方法可以整理系统资源或者执行其他清理工作。

## 11、Object中有哪些方法？

1. `protected Object clone()`——创建并返回此对象的一个副本。

2. `boolean equals(Object obj)`——指示某个其它对象是否与此对象相等。

3. `protected void finalize()`——当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。

4. `Class<? extends Object> getClass()`——返回一个对象的运行时类。

5. `int hashCode()`——返回该对象的哈希码值。

6. `void notify()`——唤醒在此对象监视器上等待的单个线程。

7. `void notifyAll()`——唤醒在此对象监视器上等待的所有线程。

8. `String toString()`——返回该对象的字符串表示。

9. > `void wait()`——导致当前的线程等待，直到其他线程调用此对象的`notify()`方法或`notifyAll()`方法。
   >
   > `void wait(long timeout)`——导致当前的线程等待，直到其他线程调用此对象的`notify()`方法或`notifyAll()`方法，或者超过指定的时间量，`timeout`以毫秒为单位。
   >
   > `void wait(long timeout, int nanos)`——导致当前的线程等待，直到其他线程调用此对象的`notify()`方法或`notifyAll()`方法，或者超过指定的时间量，`nanos`以纳秒为单位，表示额外要等待的超时时间，相当于在timeout的基础上加上nanos。

## 12、集合体系

![集合框架体系图](./assets/3d8f208789483d9d11df9bcd2de32796.png)

```mathematica
java.util.Collection (顶层接口)
├── java.util.List（有序、可重复）
│   ├── java.util.ArrayList
│   ├── java.util.LinkedList
│   └── java.util.Vector
│       └── java.util.Stack
├── java.util.Set（无序、不可重复）
│   ├── java.util.HashSet
│   ├── java.util.LinkedHashSet
│   └── java.util.TreeSet
└── java.util.Queue（队列，FIFO）
    ├── java.util.PriorityQueue
    └── java.util.Deque（双端队列）
        ├── java.util.LinkedList
        └── java.util.ArrayDeque

java.util.Map（键值对）
├── java.util.HashMap
├── java.util.LinkedHashMap
├── java.util.TreeMap
└── java.util.Hashtable
```

