[TOC]

# JVM

## JVM组成

| 名称                                     | 是否线程私有   | 主要作用说明                                                 |
| ---------------------------------------- | -------------- | ------------------------------------------------------------ |
| **方法区（Method Area）**                | 否（线程共享） | 存放类的元信息（类结构、常量池、静态变量、JIT 编译代码等）。Java 8 后为**元空间**，使用本地内存。 |
| **堆内存（Heap）**                       | 否（线程共享） | 存储**所有对象实例**和数组，是 GC 的主要区域。               |
| **Java 栈内存（JVM Stack）**             | 是（线程私有） | 方法调用时创建栈帧，保存局部变量、操作数栈、返回值等。       |
| **Native 栈内存（Native Method Stack）** | 是（线程私有） | 用于支持 Native 方法的调用（如 JNI）。                       |
| **程序计数器（Program Counter）**        | 是（线程私有） | 指示当前线程所执行的字节码行号地址，类似“行号指针”。         |

![59a1cd98b61671b569e9817708de262a](./assets/59a1cd98b61671b569e9817708de262a.png)

### 什么是程序计数器

> 线程私有的，每个线程一份，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。

### 详细介绍一下Java堆

> 线程**共享**的区域：主要用来保存**对象实例，数组**等，当堆中没有内存空间可以分配给实例，也无法再扩展时，则抛出OutOfMemoryError（OOM）异常。

#### 组成

- 年轻代：Eden区和两个大小严格相同的Survivor区。
- 老年代：主要保存生命周期长的对象，一般是一些老的对象。

#### Jdk1.7和1.8的区别

- 1.7中有一个永久代，存储的是类信息、静态变量、常量、编译后的代码。
- 1.8移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出。

### 什么是虚拟机栈

#### 介绍

- 每个线程运行时所需要的内存，称为虚拟机栈，先进后出。
- 每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。

#### 垃圾回收是否设计栈内存

- 垃圾回收主要指的就是堆内存，当栈帧弹栈以后，内存就会释放。

#### 栈内存分配是否越大越好

- 未必，默认的栈内存通常为1024k
- 栈帧过大会导致线程数变少，例如，机器总内存为512M，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半

#### 方法内的局部变量是否线程安全

- 如果方法内局部变量没有逃离方法的作用范围，它是线程安全的
- 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全。

#### 栈内存溢出情况

- 栈帧过多导致内存溢出，典型问题：递归调用
- 栈帧过大导致栈内存溢出

#### 能不能解释一下方法区

- 方法区是各个线程共享的内存区域

- 主要存储类的信息（Class、ClassLoader）、运行时常量池

- 虚拟机启动的时候创建，关闭虚拟机时释放

- 如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError：Metaspace（OOM）

- 常量池

  > 常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。方法的机器指令执行时会去常量池中“查表”

  - 常量池是`*.class`文件中的，当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。

#### 你听过直接内存吗

> 直接内存：并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存，常见于NIO操作时，用于数据缓冲区，它分配回收成本较高，但读写性能高。

## 类加载器

> JVM只会运行二进制文件，类加载器的作用就是将字节码文件加载到JVM中，从而让Java程序能够启动起来。

| 名称                  | 加载内容              | 类型           | 描述                       |
| --------------------- | --------------------- | -------------- | -------------------------- |
| BootStrap ClassLoader | JAVA_HOME/jre/lib     | 启动类加载器   | 由C++编写实现              |
| ExtClassLoader        | JAVA_HOME/jre/lib/ext | 扩展类加载器   |                            |
| AppClassLoader        | CLASSPATH             | 应用类加载器   | 加载开发者自己编写的Java类 |
| CustomizeClassLoader  |                       | 自定义类加载器 |                            |

### 什么是双亲委派模型

> 加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类

- 通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。
- 为了安全，保证类库API不会被修改。

### 说一下类装载的执行过程

> Java中类的装载过程开始于第一次主动使用该类时，称为延迟加载。即JVM只有在确实需要该类时，才会触发类的加载过程。 包括1.创建类的实例。2.访问；类的静态变量或静态方法。3.使用反射操作类。4.初始化子类时先加载父类。5.虚拟机启动时指定的主类。

1. 加载

   > 通过类的全ing，获取类的二进制数据流；
   >
   > 解析类的二进制数据流为方法区内的数据结构（Java类模型）；
   >
   > 创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口。

2. 验证（属于连接）

   > 验证类是否符合JVM规范，安全性检查
   >
   > （1）文件格式验证
   >
   > （2）元数据验证
   >
   > （3）字节码验证：以上三个都是格式检查：文件格式是否正确我、语法是否错误、字节码是否合规
   >
   > （4）符号引用验证：Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法，检查它们是否存在

3. 准备（属于连接）

   > 为类变量（static修饰的变量）分配内存并设置类变量初始值
   >
   > - static变量，分配空间在主备阶段完成（设置默认值），赋值在初始化阶段完成。
   > - static变量是final的基本类型，以及字符串常量，值以确定，赋值在准备阶段完成。
   > - static变量是final的引用类型，那么赋值也会在初始化阶段完成。

4. 解析（属于连接）

   > 把类中的符号引用转换为直接引用
   >
   > 比如：调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法。

5. 初始化

   > 对类的静态变量，静态代码块执行初始化操作。
   >
   > - 如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。
   > - 如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。

6. 使用

   > JVM开始从入口方法开始执行用户的程序代码
   >
   > - 调用静态类成员信息
   > - 使用new关键字为其创建对象实例

7. 卸载

   > 当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象。

## 垃圾回收

### 对象什么时候可以被垃圾回收器回收

> 如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。
>
> 如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法

#### 引用计数法

- 一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收。

- 当对象间出现了循环引用的话，则引用计数法就会失效。

#### 可达性分析算法

- Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象
- 扫描堆中的对象，看是1否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收

> **哪些对象可以作为GC Root？**
>
> 1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
> 2. 方法区中类静态属性引用的对象
> 3. 方法区中常量引用的对象
>
> 4. 本地方法栈中JNI（即一般说的Native方法）引用的对象

### JVM垃圾回收的算法有哪些

#### 标记清除算法

> 将垃圾回收分为2个阶段，分别是标记和清除。
>
> 1. 根据可达性分析算法得出的垃圾进行标记
> 2. 对这些标记为可回收的内容进行垃圾回收

- 缺点：容易产生内存碎片，内存不连贯

#### 标记整理算法

> 先使用标记清除算法进行清除，然后剩余的对象向一段进行移动整理。

- 效率较慢

#### 复制算法

> 将内存分为两个区域
>
> 根据可达性分析算法标记存活的对象，并将对象移动到另一块内存区域，移动时也相应整理了。
>
> 然后将原本的内存区域完全清空。

- 优点：在垃圾对象多的情况下，效率较高。清理后，内存无碎片

- 缺点：由于需要两块内存空间，所以内存利用率较低。

### 说一下JVM中的分代回收

在Java8中，堆被分为了两份：新生代和老年代【1：2】

> 对于新生代，内部又被分为了三个区域。
>
> - 伊甸园区Eden，新生的对象都分配到这里
> - 幸存者区survivor（分成from和to）
> - Eden区，from区，to区【8：1：1】

#### 工作机制

- 新创建的对象，都会先分配到eden区
- 当eden区内存不足，标记eden区与from的存活对象
- 将存活对象采用复制算法复制到to中，复制完毕后，eden区和from内存都得到释放
- 经过一段时间后eden区的内存又出现不足，标记eden区和to区存活的对象，将存活的对象复制到from区
- 当幸存者区对象熬过几次回收（最多15次），晋升到老年代（幸存区不足或大对象会导致提前晋升）

#### Minor GC、Mixed GC、Full GC的区别是什么

> STW（Stop-The-World）：暂停所有引用程序线程，等待垃圾回收完成

- Minor GC(young GC)：发生在新生代的垃圾回收，暂停时间短（STW）
- Mixed GC：新生代+老年代部分区域的垃圾回收，G1收集器特有
- FullGC：新生代+老年代完整垃圾回收，暂停时间长（STW），应尽力避免。

### 说一下JVM有哪些垃圾回收器

#### 串行垃圾回收器

Serial和Serial Old串行垃圾回收器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑

- Serial作用于新生代，采用复制算法
- Serial Old作用于老年代，采用标记-整理算法

垃圾回收时，只有一个线程在工作，并且Java应用中共的所有线程都要暂停（STW），等待垃圾回收完成。

#### 并行垃圾回收器

Parallel New和Parallel Old是一个并行垃圾回收器，**JDK8默认使用此垃圾回收器**

- Parallel New作用于新生代，采用复制算法
- Parallel Old作用于老年代，采用标记-整理算法

垃圾回收时，多个线程在工作，并且Java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。

#### CMS（并发）垃圾回收器

CMS全称Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对**老年代**垃圾回收的，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行。

#### G1垃圾回收器

- 应用于新生代和老年代，在JDK9之后默认使用G1
- 划分成多个区域，每个区域都可以充当eden，survivor，old，humongous，其中humongous专为大对象准备
- 采用复制算法
- 响应时间与吞吐量兼顾
- 分成三个阶段：新生代回收、并发标记、混合收集
- 如果并发失败（即回收速度赶不上创建对象速度），会触发Full GC

### 详细说一下G1垃圾回收器

> G1垃圾回收器应用于新生代和老年代，在jdk9之后默认使用，分成三个阶段：新生代回收、并发标记、混合收集

#### Young Collection（年轻代垃圾回收）

- 初始时，所有区域都处于空闲状态。
- 创建了一些对象，挑出一些空闲区域作为eden存储这些对象
- 当eden需要垃圾回收时，挑出一个区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程

- 随着时间流逝，eden的内存又有不足
- 将eden以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代

#### Young Collection + Concurrent Mark（年轻代垃圾回收+并发标记）

- 当老年代占用内存超过阈值（默认是45%）后，触发并发标记，这时无需暂停用户线程
- 并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。
- 这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据暂停时间目标优先回收价值高（存活对象少）的区域（Garbage First）

#### Mixed Collection（混合垃圾回收）

- 混合收集阶段中，参与复制的有eden、survivor、old。`eden+survivor → new survivor`，`Garbage First old → new old`

- 复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集。

### G1垃圾回收器回收过程

#### 1. Young GC（Minor GC）

- 回收 Eden 区，存活对象复制到 Survivor 或 Old 区。
- 停顿时间短，由多个线程并行完成。

#### 2. Mixed GC

- 在堆内存使用率达到阈值后，G1 会执行 Mixed GC。
- 同时回收 Young 区 和 **部分 Old 区**，但不是整个 Old 区。

#### 3. Full GC

- 极少发生，只在内存耗尽或并发失败时触发。
- 单线程执行，耗时长（尽量避免）。

#### G1垃圾回收常用参数

```bash
-XX:+UseG1GC                            # 启用 G1 收集器
-XX:MaxGCPauseMillis=200               # 设置最大 GC 停顿时间（目标）
-XX:InitiatingHeapOccupancyPercent=45 # 触发 Mixed GC 的阈值
-XX:ParallelGCThreads=8                # GC 使用的并行线程数
-XX:G1HeapRegionSize=8m                # 设置每个 Region 大小
```

### 强引用、软引用、弱引用、虚引用的区别

| 引用类型   | 回收时机                         | 是否参与 GC 判断 | 典型用途                         | 类名               |
| ---------- | -------------------------------- | ---------------- | -------------------------------- | ------------------ |
| **强引用** | 永不回收（除非内存不足）         | ❌ 不可回收       | 普通对象引用                     | 无（默认引用）     |
| **软引用** | 内存不足时回收                   | ✅ 优先级低       | 缓存（如图片、网页）             | `SoftReference`    |
| **弱引用** | GC 时立即回收（只要发现）        | ✅ 更易回收       | ThreadLocal Map key 等弱关联数据 | `WeakReference`    |
| **虚引用** | GC 时回收，并通知 ReferenceQueue | ✅ 最弱引用       | 清理前通知、资源释放监控         | `PhantomReference` |

1. **强引用（Strong Reference）**

```java
Object obj = new Object(); // 强引用
```

- JVM 不会回收该对象，除非 `obj` 设为 null。

2. **软引用（SoftReference）**

```java
SoftReference<Object> softRef = new SoftReference<>(new Object());
```

- 内存充足时不会被回收；内存紧张时才会被 GC。
- 常用于实现**内存敏感缓存**。

3. **弱引用（WeakReference）**

```java
WeakReference<Object> weakRef = new WeakReference<>(new Object());
```

- GC 时一定会被清除，即使内存充足。
- 常见于 ThreadLocal、WeakHashMap。

4. **虚引用（PhantomReference）**

```java
PhantomReference<Object> phantomRef = new PhantomReference<>(new Object(), referenceQueue);
```

- 本身不会影响对象生命周期。
- 对象被 GC 后会进入 `ReferenceQueue`，常用于资源释放前的通知。

## JVM实践

### JVM调优的参数可以在哪里设置参数值

- war包部署：在tomcat中设置：`TOMCAT_HOME/bin/catalina.sh`，修改`JAVA_OPTS="-Xms512m"`

- jar包部署：在启动参数设置：`java -Xms512m -java xxx.jar --spring.profiles.active=prod`

### JVM调优的参数有哪些？

> 对于JVM调优，主要就是调整年轻代、老年代、元空间的内存空间大小及使用的垃圾回收器类型

#### 堆内存设置

| 参数                        | 说明                                                         |
| --------------------------- | ------------------------------------------------------------ |
| `-Xms<size>`                | 初始堆大小（建议与 `-Xmx` 相同，避免频繁扩容）               |
| `-Xmx<size>`                | 最大堆大小（如 `-Xmx2g`）                                    |
| `-Xmn<size>`                | 新生代大小（Old 为总堆减去该值）                             |
| `-XX:NewRatio=n`            | 老年代 / 新生代比例，如 `-XX:NewRatio=2` 表示 1/3 新生代，2/3 老年代 |
| `-XX:SurvivorRatio=n`       | Eden / Survivor 比例，默认 `8:1:1`，即 `-XX:SurvivorRatio=8` |
| `-XX:MaxMetaspaceSize=256m` | 设置元空间（类加载空间）最大值                               |

#### 栈内存设置

| 参数                    | 作用                      | 说明                                    |
| ----------------------- | ------------------------- | --------------------------------------- |
| `-Xss<size>`            | 每个线程的栈大小          | 默认值：一般为 1MB（不同平台可能不同）  |
| `-XX:ThreadStackSize=n` | 设置线程栈大小（单位 KB） | 与 `-Xss` 功能类似，部分 JVM 使用此参数 |

#### GC类型设置

| 参数                             | 垃圾收集器                   |
| -------------------------------- | ---------------------------- |
| `-XX:+UseSerialGC`               | 串行回收器（小内存）         |
| `-XX:+UseParallelGC`             | 吞吐量优先（默认 JDK8）      |
| `-XX:+UseConcMarkSweepGC`        | CMS，并发低延迟（JDK9 及前） |
| `-XX:+UseG1GC`                   | G1，低延迟、分区回收         |
| `-XX:+UseZGC`（JDK11+）          | 超低延迟，适合大内存         |
| `-XX:+UseShenandoahGC`（JDK12+） | RedHat 开发的并发收集器      |

#### GC调优参数

| 参数                               | 说明                                |
| ---------------------------------- | ----------------------------------- |
| `-XX:MaxGCPauseMillis=200`         | G1 等收集器的最大停顿时间目标（ms） |
| `-XX:+PrintGCDetails`              | 输出 GC 详细信息                    |
| `-Xlog:gc*`（JDK9+）               | GC 日志统一日志接口                 |
| `-XX:+UseStringDeduplication`      | 启用字符串去重（G1 专用）           |
| `-XX:+ExplicitGCInvokesConcurrent` | `System.gc()` 使用并发 GC           |

#### 诊断与监控参数

| 参数                                   | 说明                        |
| -------------------------------------- | --------------------------- |
| `-XX:+PrintGCDateStamps`               | 打印 GC 时间戳              |
| `-XX:+HeapDumpOnOutOfMemoryError`      | OOM 时生成堆转储文件        |
| `-XX:HeapDumpPath=xxx.hprof`           | 指定堆转储路径              |
| `-XX:+PrintFlagsFinal`                 | 输出所有 JVM 参数及其默认值 |
| `-XX:+UnlockDiagnosticVMOptions`       | 解锁诊断参数                |
| `-XX:+PrintClassHistogramBeforeFullGC` | 打印类占用信息              |
| `-XX:+UseGCLogFileRotation`            | GC 日志滚动策略             |

#### JIT 与性能相关参数

| 参数                         | 说明                     |
| ---------------------------- | ------------------------ |
| `-XX:+TieredCompilation`     | 启用分层编译（默认开启） |
| `-XX:+PrintCompilation`      | 打印 JIT 编译的方法信息  |
| `-XX:CompileThreshold=10000` | 热点代码编译阈值         |

### JVM调优工具

| 工具名       | 功能                                | 使用方式                              |
| ------------ | ----------------------------------- | ------------------------------------- |
| `jps`        | 列出当前 JVM 进程                   | `jps -l` 查看完整类名                 |
| `jstat`      | 查看 GC、类加载、内存使用等统计信息 | `jstat -gc <pid>`                     |
| `jstack`     | 导出线程堆栈，用于死锁/高 CPU 分析  | `jstack <pid>`                        |
| `jmap`       | 查看内存使用、导出堆快照            | `jmap -heap` / `-dump:file=xxx.hprof` |
| `jinfo`      | 查看/修改 JVM 参数                  | `jinfo -flags <pid>`                  |
| `jcmd`       | 综合工具，可代替上述大部分命令      | `jcmd <pid> help`                     |
| **VisualVM** | 图形界面分析 GC、堆、线程、方法耗时 | 需要安装，支持插件                    |
| **JConsole** | 可视化监控内存、线程、类、MBean 等  | `jconsole` 启动                       |

#### Arthas

- 下载地址：https://arthas.aliyun.com/arthas-boot.jar

**常用命令**

- dashboard，查看面板
- thread 8，定位线程问题
- thread -b，查看阻塞线程原因
- jad com.packge.name 反编译包
- ognl 命令可以查看线上系统变量的值，甚至可以修改变量的值

### 反汇编

`javap -c main.class > out.txt`反汇编class文件

### Java内存泄漏的排查思路

1. 导出堆快照

> - 使用jmap命令获取运行中程序的dump文件
>
>   ```bash
>   jmap -dump:live,format=b,file=heap.hprof <pid>
>   ```
>
> - 使用vm参数获取dump文件（有的情况是内存溢出之后程序则会直接中断，而jmap只能打印在运行中的程序，所以建议通过参数的方式生成Dump文件
>
>   ```bash
>   -XX:+HeapDumpOnOutOfMemoryError
>   -XX:HeapDumpPath=./dump.hprof
>   ```

2. 通过工具分析`.hprof`

> - 查找内存占用最多的对象：注意是否有某类对象（如 `ArrayList`, `HashMap`, `byte[]`）实例数量或内存占用异常高。
> - 分析 GC Roots 引用链：分析为什么该对象没有被 GC 回收（被谁引用着）
> - 查看保留堆大小（Retained Heap）：表示“删除某个对象后能释放的总内存”

3. 常见泄露特征

| 场景                                 | 描述                                    |
| ------------------------------------ | --------------------------------------- |
| **静态集合**                         | `Map`, `List` 为 static，被无限添加元素 |
| **ThreadLocal**                      | 未手动移除引用，导致线程无法回收        |
| **Listener / 回调**                  | 注册后未移除，如事件监听器              |
| **缓存实现**                         | 没有清理机制或使用强引用                |
| **连接/资源未关闭**                  | 未关闭 JDBC/IO/Socket，间接保留引用     |
| **长生命周期对象持有短生命周期对象** | 例如缓存中保留页面请求对象              |

### CPU飙高排查方案与思路

 1. 定位占用 CPU 高的进程

```bash
# 查看占用高的进程
top -Hp <java_pid>       # -H 显示线程
htop                     # 更直观，支持按 CPU 排序
```

- 找到占用高的线程（注意 Thread ID）

2. 将线程 ID 转换为十六进制（用于后续匹配）

```bash
printf "%x\n" <线程ID>
# 例如：线程 ID 为 10100，转为十六进制为 2774
```

3. 打印线程栈信息，定位“哪段代码”导致高 CPU

```bash
jstack <java_pid> > jstack.log
```

- 在 `jstack.log` 中搜索对应的十六进制线程 ID（注意前缀补 0，如 `0x00002774`）
- 找到线程栈，**重点看栈顶的方法调用**

4. 常见高CPU原因

| 原因                       | 表现                                          | 说明                       |
| -------------------------- | --------------------------------------------- | -------------------------- |
| 死循环 / 频繁轮询          | 栈顶是循环内逻辑                              | CPU 被无效逻辑打满         |
| 大量 JSON 解析、字符串拼接 | 栈顶是 `Jackson/Gson`、`StringBuilder.append` | CPU 密集操作               |
| 锁竞争（线程频繁争用）     | 栈中频繁有 `synchronized` / `ReentrantLock`   | 自旋导致 CPU 高            |
| GC 频繁                    | 多为 JVM GC 线程                              | 查看 GC 日志，分析回收情况 |
| 网络/IO阻塞引发反复重试    | 栈中有 `read` / `poll` 等                     | IO异常未处理               |

