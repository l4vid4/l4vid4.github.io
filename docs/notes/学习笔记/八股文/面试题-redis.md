## 1. 缓存穿透

> **缓存穿透**是指：**请求的数据在缓存（如 Redis）和数据库中都不存在，导致每次请求都会穿过缓存直接请求数据库**，从而失去了缓存的意义，严重时可能压垮数据库。

### 解决方案

#### 1. 缓存空值

- 即：对于查询结果为 `null` 的数据，也写入缓存。

- 示例：

  ```redis
  SET user:999999 null EX 300
  ```

- 设置一个较短的过期时间，避免缓存占用过多空间。

> 缺点：可能消耗内存，或造成数据不一致的问题。

#### 2. 布隆过滤器（Bloom Filter）

- 在访问缓存之前，先用布隆过滤器判断 key 是否可能存在；
- 若布隆过滤器判断为“不存在”，就直接拦截请求；
- 优点：占用空间小，性能高；
- 缺点：有**误判率**（可能判断存在，但实际不存在）。

> **布隆过滤器**
>
> - 采用bitmap（位图）数组。
> - 存储数据：id为1的数据，通过多个hash函数获取hash值，根据hash计算数组对应位置改为1。
> - 查询数据：使用相同hash函数获取hash值，判断对应位置是否都为1。
> - 误判率可以在初始化时手动设置，一般为0.05.

#### 3. 参数校验

- 对传入的参数（如 ID）进行格式校验；
- 非法参数直接拒绝请求，不查询缓存或数据库。

#### 4. 接口限流与验证码

- 对频繁请求的 IP 或用户加限制；
- 对可疑请求增加验证码验证，避免恶意攻击。

## 2. 缓存击穿

> **缓存击穿**是指：某个热点数据在缓存中失效（过期）的一瞬间，有大量并发请求同时访问该数据，由于缓存没有命中，导致这些请求都直接访问数据库，造成数据库压力剧增甚至宕机。

### 解决方案

#### 1. 设置热点数据永不过期（或很长过期时间）

- 对于访问频繁的数据，可以设置较长 TTL，甚至不设过期时间；
- 由后台程序定期更新缓存，而不是自动失效。

#### 2. 使用互斥锁（如分布式锁）

> 特点：强一致，性能差

- 当缓存失效时，**只有一个线程能去加载数据库并回填缓存**；

- 其余线程等待或短时间重试，防止并发访问数据库；

- 示例伪代码：

  ```java
  if (redis.get(key) == null) {
      if (acquireLock(key)) {
          value = queryDatabase();
          redis.set(key, value, ttl);
          releaseLock(key);
      } else {
          sleep(50ms);
          retry();
      }
  }
  
  ```

#### 3. 利用异步更新 + 逻辑过期

> 特点：高可用，性能优

- 缓存数据不真实删除，而是加上一个“逻辑过期时间”（在设置key的时候一并存入缓存）；
- 请求到达时若数据已逻辑过期，则：
  - 先返回旧值；
  - 异步由后台线程更新缓存，避免并发冲击；
- 常用于读多写少的场景（如热点文章详情页）。

#### 4. 提前预热缓存

- 对于已知的热点数据（如大促商品、首页模块等），**在系统启动或业务高峰前提前加载进缓存**，避免过期带来的击穿。

## 3. 缓存雪崩

> **缓存雪崩**是指：**大量缓存数据在同一时间集中过期或失效或者Redis服务宕机，导致大批请求绕过缓存直接访问数据库，引起数据库压力骤增甚至崩溃**，从而造成整个系统不可用。

### 解决方案

#### 1. 缓存过期时间加随机值

- 避免所有 key 过期时间一致；
- 示例：设置过期时间为 `600s + random(0~300s)`；
- 这样 key 的过期时间分散，避免集中过期。

#### 2. 利用Redis集群提高服务的可用性

**主从复制 + 哨兵模式（Sentinel）**

- Redis 主从架构，主节点写、从节点读；
- 配合哨兵（Sentinel）自动监控主节点健康；
- 主节点宕机时，哨兵自动完成故障转移（选举新的主节点）；
- 客户端自动感知主节点变化，保障服务不中断。

**Redis Cluster 模式**

- 数据分片到多个节点，每个节点负责部分 key；
- 自动管理主从结构和数据分布；
- 某个节点宕机时，其从节点可自动顶替，保证整体服务可用；
- 适用于大数据量 + 高并发场景。

#### 3. 使用多级缓存架构

- 如：本地缓存（Guava、Caffeine） + 分布式缓存（Redis）；
- 缓解 Redis 失效时对数据库的直接冲击；
- 缺点是增加系统复杂性。

#### 4. 请求限流与降级处理

- 设置接口限流策略，避免短时间请求爆发；
- 数据库压力过高时返回降级数据（如旧值、提示信息等）；
- 保证系统核心功能可用。

### 缓存三兄弟

| 名称     | 触发条件                  | 涉及 key         | 是否因攻击可控 | 解决重点               |
| -------- | ------------------------- | ---------------- | -------------- | ---------------------- |
| 缓存穿透 | 缓存和数据库都无该数据    | 大量不存在的 key | 可被恶意触发   | 拦截非法请求           |
| 缓存击穿 | 热点 key 过期被高并发访问 | 单个热点 key     | 部分可控       | 限流 + 加锁 + 异步更新 |
| 缓存雪崩 | 大量 key 同时过期         | 大批有效 key     | 通常不可控     | 平滑过期 + 异步预热    |

> 打油诗：
>
> 穿透无中生有key，布隆过滤null隔离。
>
> 缓存击穿过期key，锁与非期解难题。
>
> 雪崩大量过期key，过期时间要随机。
>
> 面试必考三兄弟，可用限流来保底。