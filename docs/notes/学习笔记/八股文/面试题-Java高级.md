## 1. HashMap底层源码

> [HashMap详解](https://blog.csdn.net/v123411739/article/details/78996181)

### 数据结构

**数组（Node[] table）**：HashMap 的主体，存储键值对节点。

**链表**：解决哈希冲突的主要方式（Java 8 之前）。

**红黑树**：当单个桶中的元素超过阈值（默认 8），链表转换为红黑树，提高查询效率（Java 8 起）。

![af1ea7d9965ada42d97f8d10c5e879b9](./assets/af1ea7d9965ada42d97f8d10c5e879b9.png)

### 核心流程

#### 存储（put）

> 1. 计算键的 `hash` 值。
>
> 2. 根据 `hash % table.length` 定位数组索引。
>
> 3. 如果该位置为空，直接插入；
>    如果不为空，遍历链表或树：
>
>    - key 已存在：更新 value；
>
>    - key 不存在：添加新节点，必要时树化。

- put方法流程图。

![73496942ccf51c9890d23ba12f5d4932](./assets/73496942ccf51c9890d23ba12f5d4932.png)

#### 查询（get）

1. 计算 `hash`。

2. 定位数组索引。

3. 根据 key 遍历链表或红黑树，匹配相同 key。

### 负载因子

- 默认负载因子：0.75
- 当元素数量 > 阈值（capacity × load factor）时，数组扩容为原来的 2 倍，重新哈希分布所有节点。

### 特点

- key 允许为 null（最多一个）。
- 非线程安全（需使用 `Collections.synchronizedMap` 或 `ConcurrentHashMap`）。

## 2. JVM内存分哪几个区，每个区的作用是什么

| 名称                                     | 是否线程私有   | 主要作用说明                                                 |
| ---------------------------------------- | -------------- | ------------------------------------------------------------ |
| **方法区（Method Area）**                | 否（线程共享） | 存放类的元信息（类结构、常量池、静态变量、JIT 编译代码等）。Java 8 后为**元空间**，使用本地内存。 |
| **堆内存（Heap）**                       | 否（线程共享） | 存储**所有对象实例**和数组，是 GC 的主要区域。               |
| **Java 栈内存（JVM Stack）**             | 是（线程私有） | 方法调用时创建栈帧，保存局部变量、操作数栈、返回值等。       |
| **Native 栈内存（Native Method Stack）** | 是（线程私有） | 用于支持 Native 方法的调用（如 JNI）。                       |
| **程序计数器（Program Counter）**        | 是（线程私有） | 指示当前线程所执行的字节码行号地址，类似“行号指针”。         |

![59a1cd98b61671b569e9817708de262a](./assets/59a1cd98b61671b569e9817708de262a.png)

| 名称                                     | 是否线程私有   | 主要作用说明                                                 |
| ---------------------------------------- | -------------- | ------------------------------------------------------------ |
| **方法区（Method Area）**                | 否（线程共享） | 存放类的元信息（类结构、常量池、静态变量、JIT 编译代码等）。Java 8 后为**元空间**，使用本地内存。 |
| **堆内存（Heap）**                       | 否（线程共享） | 存储**所有对象实例**和数组，是 GC 的主要区域。               |
| **Java 栈内存（JVM Stack）**             | 是（线程私有） | 方法调用时创建栈帧，保存局部变量、操作数栈、返回值等。       |
| **Native 栈内存（Native Method Stack）** | 是（线程私有） | 用于支持 Native 方法的调用（如 JNI）。                       |
| **程序计数器（Program Counter）**        | 是（线程私有） | 指示当前线程所执行的字节码行号地址，类似“行号指针”。         |

## 3. Java中垃圾回收（GC）的方式有哪些

### 按回收算法分类

| 算法名称                     | 原理简介                                                     | 优点                                         | 缺点                                                 | 适用场景                 |
| ---------------------------- | ------------------------------------------------------------ | -------------------------------------------- | ---------------------------------------------------- | ------------------------ |
| **标记-清除** (Mark-Sweep)   | 标记所有存活对象 → 清除未标记对象                            | 实现简单，无需复制，节省空间                 | 会产生**内存碎片**，回收速度慢，分配大对象可能失败   | 老年代（早期使用）       |
| **复制算法** (Copying)       | 存活对象复制到另一块区域，清空原区域                         | **无碎片**，分配连续内存，回收快             | 空间浪费大（只能用一半），对象存活率高时，复制开销大 | 新生代（对象生命周期短） |
| **标记-整理** (Mark-Compact) | 标记存活对象 → 整理到一端 → 清理无效对象                     | 无碎片，不浪费内存，支持大对象分配           | 移动对象成本高，整理耗时                             | 老年代（对象存活率高）   |
| **分代收集** (Generational)  | 将内存划分为新生代、老年代，分别使用不同算法（如复制 + 标记整理） | 综合多种算法优点，高效适应不同生命周期的对象 | 实现复杂，分代调整策略需要调优                       | JVM 默认策略             |

### 按垃圾回收器名称分类（HotSpot JVM 常见 GC）

| 回收器                              | 适用区域                  | 特点                                           |
| ----------------------------------- | ------------------------- | ---------------------------------------------- |
| **Serial**                          | 新生代（复制算法）        | 单线程，适用于小内存、单核。                   |
| **ParNew**                          | 新生代（复制算法）        | 多线程版 Serial，可与 CMS 搭配使用。           |
| **Parallel Scavenge（吞吐量优先）** | 新生代（复制算法）        | 多线程，追求高吞吐量，配合 Parallel Old 使用。 |
| **Parallel Old**                    | 老年代（标记-整理）       | Parallel Scavenge 的老年代回收器。             |
| **CMS（Concurrent Mark Sweep）**    | 老年代（标记-清除）       | 并发低停顿，适合响应时间敏感应用；有碎片问题。 |
| **G1（Garbage First）**             | 新生代+老年代（分区回收） | 支持并发、低停顿、可预测，适合大内存。         |
| **ZGC（Java 11+）**                 | 全区域并发回收            | 极低停顿（<10ms），支持大内存（TB 级）。       |
| **Shenandoah（Java 12+）**          | 全区域并发回收            | 类似 ZGC，适合低延迟场景。                     |

## 4. 如何判断一个对象是否存活(或者GC对象的判定方法)

### 引用计数法（Reference Counting，已淘汰）

#### 原理：

- 每个对象维护一个**引用计数器**，被引用一次计数加一，引用断开减一；
- 计数为 0 的对象会被判定为垃圾。

#### 缺点：

- 无法处理**循环引用**，比如两个对象互相引用但已无外部引用，仍然无法被回收；
- 因此被 **HotSpot JVM** 等主流虚拟机淘汰。

### 可达性分析算法（Reachability Analysis，主流）

#### 原理：

- 从一组称为 **GC Roots** 的对象出发，向下搜索，能连通的对象为**可达对象**，否则为垃圾；
- **不可达 ≠ 立即死亡**，还可能进入 “**四次判死**” 机制。

#### GC Roots 包括：

- 虚拟机栈中的**引用变量**（方法栈帧中的局部变量表）
- 方法区中的**类静态属性**
- 方法区中的**常量引用**
- 本地方法栈中 JNI 引用（Native 方法）

#### 对象“真正死亡”前的判断过程

- 对于不可达对象，还要经历如下判定才会被彻底GC：

| 判定阶段       | 条件                                  | 说明                              |
| -------------- | ------------------------------------- | --------------------------------- |
| **第一次判定** | 是否重写 `finalize()` 方法            | 如果没有，立即判定为垃圾          |
| **第二次判定** | 执行 `finalize()`，是否重新建立引用链 | 有引用则“复活”；否则进入下一轮 GC |
| **最终回收**   | finalize 后仍不可达                   | 判定死亡，GC 回收                 |

> **finalize()**：
>
> - 在对象被 GC 前做一些**资源释放**、**日志记录**等清理工作；
> - 允许对象“**自救**”，即在 `finalize()` 中重新让自己变为可达对象（比如把 `this` 赋值给某个静态变量）。
> - GC 判定对象“不可达”后，若重写了 `finalize()`：
>   - 会将该对象放入 `F-Queue`（Finalizer Reference Queue）；
>   - 由一个 JVM 内部线程（Finalizer Thread）异步调用其 `finalize()` 方法；
>   - 如果在方法中重新建立引用链，GC 会“放你一马”；
>   - 每个对象的 `finalize()` **最多只会被调用一次**。