import{_ as i}from"./59a1cd98b61671b569e9817708de262a-5KDefroA.js";import{_ as a,c as s,a as e,o as d}from"./app-dsZ4C4U9.js";const l={};function h(n,t){return d(),s("div",null,t[0]||(t[0]=[e('<p>[TOC]</p><h1 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm"><span>JVM</span></a></h1><h2 id="jvm组成" tabindex="-1"><a class="header-anchor" href="#jvm组成"><span>JVM组成</span></a></h2><table><thead><tr><th>名称</th><th>是否线程私有</th><th>主要作用说明</th></tr></thead><tbody><tr><td><strong>方法区（Method Area）</strong></td><td>否（线程共享）</td><td>存放类的元信息（类结构、常量池、静态变量、JIT 编译代码等）。Java 8 后为<strong>元空间</strong>，使用本地内存。</td></tr><tr><td><strong>堆内存（Heap）</strong></td><td>否（线程共享）</td><td>存储<strong>所有对象实例</strong>和数组，是 GC 的主要区域。</td></tr><tr><td><strong>Java 栈内存（JVM Stack）</strong></td><td>是（线程私有）</td><td>方法调用时创建栈帧，保存局部变量、操作数栈、返回值等。</td></tr><tr><td><strong>Native 栈内存（Native Method Stack）</strong></td><td>是（线程私有）</td><td>用于支持 Native 方法的调用（如 JNI）。</td></tr><tr><td><strong>程序计数器（Program Counter）</strong></td><td>是（线程私有）</td><td>指示当前线程所执行的字节码行号地址，类似“行号指针”。</td></tr></tbody></table><p><img src="'+i+`" alt="59a1cd98b61671b569e9817708de262a"></p><h3 id="什么是程序计数器" tabindex="-1"><a class="header-anchor" href="#什么是程序计数器"><span>什么是程序计数器</span></a></h3><blockquote><p>线程私有的，每个线程一份，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。</p></blockquote><h3 id="详细介绍一下java堆" tabindex="-1"><a class="header-anchor" href="#详细介绍一下java堆"><span>详细介绍一下Java堆</span></a></h3><blockquote><p>线程<strong>共享</strong>的区域：主要用来保存<strong>对象实例，数组</strong>等，当堆中没有内存空间可以分配给实例，也无法再扩展时，则抛出OutOfMemoryError（OOM）异常。</p></blockquote><h4 id="组成" tabindex="-1"><a class="header-anchor" href="#组成"><span>组成</span></a></h4><ul><li>年轻代：Eden区和两个大小严格相同的Survivor区。</li><li>老年代：主要保存生命周期长的对象，一般是一些老的对象。</li></ul><h4 id="jdk1-7和1-8的区别" tabindex="-1"><a class="header-anchor" href="#jdk1-7和1-8的区别"><span>Jdk1.7和1.8的区别</span></a></h4><ul><li>1.7中有一个永久代，存储的是类信息、静态变量、常量、编译后的代码。</li><li>1.8移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出。</li></ul><h3 id="什么是虚拟机栈" tabindex="-1"><a class="header-anchor" href="#什么是虚拟机栈"><span>什么是虚拟机栈</span></a></h3><h4 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h4><ul><li>每个线程运行时所需要的内存，称为虚拟机栈，先进后出。</li><li>每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。</li></ul><h4 id="垃圾回收是否设计栈内存" tabindex="-1"><a class="header-anchor" href="#垃圾回收是否设计栈内存"><span>垃圾回收是否设计栈内存</span></a></h4><ul><li>垃圾回收主要指的就是堆内存，当栈帧弹栈以后，内存就会释放。</li></ul><h4 id="栈内存分配是否越大越好" tabindex="-1"><a class="header-anchor" href="#栈内存分配是否越大越好"><span>栈内存分配是否越大越好</span></a></h4><ul><li>未必，默认的栈内存通常为1024k</li><li>栈帧过大会导致线程数变少，例如，机器总内存为512M，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半</li></ul><h4 id="方法内的局部变量是否线程安全" tabindex="-1"><a class="header-anchor" href="#方法内的局部变量是否线程安全"><span>方法内的局部变量是否线程安全</span></a></h4><ul><li>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的</li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全。</li></ul><h4 id="栈内存溢出情况" tabindex="-1"><a class="header-anchor" href="#栈内存溢出情况"><span>栈内存溢出情况</span></a></h4><ul><li>栈帧过多导致内存溢出，典型问题：递归调用</li><li>栈帧过大导致栈内存溢出</li></ul><h4 id="能不能解释一下方法区" tabindex="-1"><a class="header-anchor" href="#能不能解释一下方法区"><span>能不能解释一下方法区</span></a></h4><ul><li><p>方法区是各个线程共享的内存区域</p></li><li><p>主要存储类的信息（Class、ClassLoader）、运行时常量池</p></li><li><p>虚拟机启动的时候创建，关闭虚拟机时释放</p></li><li><p>如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError：Metaspace（OOM）</p></li><li><p>常量池</p><blockquote><p>常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。方法的机器指令执行时会去常量池中“查表”</p></blockquote><ul><li>常量池是<code>*.class</code>文件中的，当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。</li></ul></li></ul><h4 id="你听过直接内存吗" tabindex="-1"><a class="header-anchor" href="#你听过直接内存吗"><span>你听过直接内存吗</span></a></h4><blockquote><p>直接内存：并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存，常见于NIO操作时，用于数据缓冲区，它分配回收成本较高，但读写性能高。</p></blockquote><h2 id="类加载器" tabindex="-1"><a class="header-anchor" href="#类加载器"><span>类加载器</span></a></h2><blockquote><p>JVM只会运行二进制文件，类加载器的作用就是将字节码文件加载到JVM中，从而让Java程序能够启动起来。</p></blockquote><table><thead><tr><th>名称</th><th>加载内容</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>BootStrap ClassLoader</td><td>JAVA_HOME/jre/lib</td><td>启动类加载器</td><td>由C++编写实现</td></tr><tr><td>ExtClassLoader</td><td>JAVA_HOME/jre/lib/ext</td><td>扩展类加载器</td><td></td></tr><tr><td>AppClassLoader</td><td>CLASSPATH</td><td>应用类加载器</td><td>加载开发者自己编写的Java类</td></tr><tr><td>CustomizeClassLoader</td><td></td><td>自定义类加载器</td><td></td></tr></tbody></table><h3 id="什么是双亲委派模型" tabindex="-1"><a class="header-anchor" href="#什么是双亲委派模型"><span>什么是双亲委派模型</span></a></h3><blockquote><p>加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类</p></blockquote><ul><li>通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</li><li>为了安全，保证类库API不会被修改。</li></ul><h3 id="说一下类装载的执行过程" tabindex="-1"><a class="header-anchor" href="#说一下类装载的执行过程"><span>说一下类装载的执行过程</span></a></h3><blockquote><p>Java中类的装载过程开始于第一次主动使用该类时，称为延迟加载。即JVM只有在确实需要该类时，才会触发类的加载过程。 包括1.创建类的实例。2.访问；类的静态变量或静态方法。3.使用反射操作类。4.初始化子类时先加载父类。5.虚拟机启动时指定的主类。</p></blockquote><ol><li><p>加载</p><blockquote><p>通过类的全ing，获取类的二进制数据流；</p><p>解析类的二进制数据流为方法区内的数据结构（Java类模型）；</p><p>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口。</p></blockquote></li><li><p>验证（属于连接）</p><blockquote><p>验证类是否符合JVM规范，安全性检查</p><p>（1）文件格式验证</p><p>（2）元数据验证</p><p>（3）字节码验证：以上三个都是格式检查：文件格式是否正确我、语法是否错误、字节码是否合规</p><p>（4）符号引用验证：Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法，检查它们是否存在</p></blockquote></li><li><p>准备（属于连接）</p><blockquote><p>为类变量（static修饰的变量）分配内存并设置类变量初始值</p><ul><li>static变量，分配空间在主备阶段完成（设置默认值），赋值在初始化阶段完成。</li><li>static变量是final的基本类型，以及字符串常量，值以确定，赋值在准备阶段完成。</li><li>static变量是final的引用类型，那么赋值也会在初始化阶段完成。</li></ul></blockquote></li><li><p>解析（属于连接）</p><blockquote><p>把类中的符号引用转换为直接引用</p><p>比如：调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法。</p></blockquote></li><li><p>初始化</p><blockquote><p>对类的静态变量，静态代码块执行初始化操作。</p><ul><li>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</li><li>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</li></ul></blockquote></li><li><p>使用</p><blockquote><p>JVM开始从入口方法开始执行用户的程序代码</p><ul><li>调用静态类成员信息</li><li>使用new关键字为其创建对象实例</li></ul></blockquote></li><li><p>卸载</p><blockquote><p>当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象。</p></blockquote></li></ol><h2 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收"><span>垃圾回收</span></a></h2><h3 id="对象什么时候可以被垃圾回收器回收" tabindex="-1"><a class="header-anchor" href="#对象什么时候可以被垃圾回收器回收"><span>对象什么时候可以被垃圾回收器回收</span></a></h3><blockquote><p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p><p>如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法</p></blockquote><h4 id="引用计数法" tabindex="-1"><a class="header-anchor" href="#引用计数法"><span>引用计数法</span></a></h4><ul><li><p>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收。</p></li><li><p>当对象间出现了循环引用的话，则引用计数法就会失效。</p></li></ul><h4 id="可达性分析算法" tabindex="-1"><a class="header-anchor" href="#可达性分析算法"><span>可达性分析算法</span></a></h4><ul><li>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li><li>扫描堆中的对象，看是1否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收</li></ul><blockquote><p><strong>哪些对象可以作为GC Root？</strong></p><ol><li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>本地方法栈中JNI（即一般说的Native方法）引用的对象</p></li></ol></blockquote><h3 id="jvm垃圾回收的算法有哪些" tabindex="-1"><a class="header-anchor" href="#jvm垃圾回收的算法有哪些"><span>JVM垃圾回收的算法有哪些</span></a></h3><h4 id="标记清除算法" tabindex="-1"><a class="header-anchor" href="#标记清除算法"><span>标记清除算法</span></a></h4><blockquote><p>将垃圾回收分为2个阶段，分别是标记和清除。</p><ol><li>根据可达性分析算法得出的垃圾进行标记</li><li>对这些标记为可回收的内容进行垃圾回收</li></ol></blockquote><ul><li>缺点：容易产生内存碎片，内存不连贯</li></ul><h4 id="标记整理算法" tabindex="-1"><a class="header-anchor" href="#标记整理算法"><span>标记整理算法</span></a></h4><blockquote><p>先使用标记清除算法进行清除，然后剩余的对象向一段进行移动整理。</p></blockquote><ul><li>效率较慢</li></ul><h4 id="复制算法" tabindex="-1"><a class="header-anchor" href="#复制算法"><span>复制算法</span></a></h4><blockquote><p>将内存分为两个区域</p><p>根据可达性分析算法标记存活的对象，并将对象移动到另一块内存区域，移动时也相应整理了。</p><p>然后将原本的内存区域完全清空。</p></blockquote><ul><li><p>优点：在垃圾对象多的情况下，效率较高。清理后，内存无碎片</p></li><li><p>缺点：由于需要两块内存空间，所以内存利用率较低。</p></li></ul><h3 id="说一下jvm中的分代回收" tabindex="-1"><a class="header-anchor" href="#说一下jvm中的分代回收"><span>说一下JVM中的分代回收</span></a></h3><p>在Java8中，堆被分为了两份：新生代和老年代【1：2】</p><blockquote><p>对于新生代，内部又被分为了三个区域。</p><ul><li>伊甸园区Eden，新生的对象都分配到这里</li><li>幸存者区survivor（分成from和to）</li><li>Eden区，from区，to区【8：1：1】</li></ul></blockquote><h4 id="工作机制" tabindex="-1"><a class="header-anchor" href="#工作机制"><span>工作机制</span></a></h4><ul><li>新创建的对象，都会先分配到eden区</li><li>当eden区内存不足，标记eden区与from的存活对象</li><li>将存活对象采用复制算法复制到to中，复制完毕后，eden区和from内存都得到释放</li><li>经过一段时间后eden区的内存又出现不足，标记eden区和to区存活的对象，将存活的对象复制到from区</li><li>当幸存者区对象熬过几次回收（最多15次），晋升到老年代（幸存区不足或大对象会导致提前晋升）</li></ul><h4 id="minor-gc、mixed-gc、full-gc的区别是什么" tabindex="-1"><a class="header-anchor" href="#minor-gc、mixed-gc、full-gc的区别是什么"><span>Minor GC、Mixed GC、Full GC的区别是什么</span></a></h4><blockquote><p>STW（Stop-The-World）：暂停所有引用程序线程，等待垃圾回收完成</p></blockquote><ul><li>Minor GC(young GC)：发生在新生代的垃圾回收，暂停时间短（STW）</li><li>Mixed GC：新生代+老年代部分区域的垃圾回收，G1收集器特有</li><li>FullGC：新生代+老年代完整垃圾回收，暂停时间长（STW），应尽力避免。</li></ul><h3 id="说一下jvm有哪些垃圾回收器" tabindex="-1"><a class="header-anchor" href="#说一下jvm有哪些垃圾回收器"><span>说一下JVM有哪些垃圾回收器</span></a></h3><h4 id="串行垃圾回收器" tabindex="-1"><a class="header-anchor" href="#串行垃圾回收器"><span>串行垃圾回收器</span></a></h4><p>Serial和Serial Old串行垃圾回收器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑</p><ul><li>Serial作用于新生代，采用复制算法</li><li>Serial Old作用于老年代，采用标记-整理算法</li></ul><p>垃圾回收时，只有一个线程在工作，并且Java应用中共的所有线程都要暂停（STW），等待垃圾回收完成。</p><h4 id="并行垃圾回收器" tabindex="-1"><a class="header-anchor" href="#并行垃圾回收器"><span>并行垃圾回收器</span></a></h4><p>Parallel New和Parallel Old是一个并行垃圾回收器，<strong>JDK8默认使用此垃圾回收器</strong></p><ul><li>Parallel New作用于新生代，采用复制算法</li><li>Parallel Old作用于老年代，采用标记-整理算法</li></ul><p>垃圾回收时，多个线程在工作，并且Java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。</p><h4 id="cms-并发-垃圾回收器" tabindex="-1"><a class="header-anchor" href="#cms-并发-垃圾回收器"><span>CMS（并发）垃圾回收器</span></a></h4><p>CMS全称Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对<strong>老年代</strong>垃圾回收的，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行。</p><h4 id="g1垃圾回收器" tabindex="-1"><a class="header-anchor" href="#g1垃圾回收器"><span>G1垃圾回收器</span></a></h4><ul><li>应用于新生代和老年代，在JDK9之后默认使用G1</li><li>划分成多个区域，每个区域都可以充当eden，survivor，old，humongous，其中humongous专为大对象准备</li><li>采用复制算法</li><li>响应时间与吞吐量兼顾</li><li>分成三个阶段：新生代回收、并发标记、混合收集</li><li>如果并发失败（即回收速度赶不上创建对象速度），会触发Full GC</li></ul><h3 id="详细说一下g1垃圾回收器" tabindex="-1"><a class="header-anchor" href="#详细说一下g1垃圾回收器"><span>详细说一下G1垃圾回收器</span></a></h3><blockquote><p>G1垃圾回收器应用于新生代和老年代，在jdk9之后默认使用，分成三个阶段：新生代回收、并发标记、混合收集</p></blockquote><h4 id="young-collection-年轻代垃圾回收" tabindex="-1"><a class="header-anchor" href="#young-collection-年轻代垃圾回收"><span>Young Collection（年轻代垃圾回收）</span></a></h4><ul><li><p>初始时，所有区域都处于空闲状态。</p></li><li><p>创建了一些对象，挑出一些空闲区域作为eden存储这些对象</p></li><li><p>当eden需要垃圾回收时，挑出一个区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</p></li><li><p>随着时间流逝，eden的内存又有不足</p></li><li><p>将eden以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</p></li></ul><h4 id="young-collection-concurrent-mark-年轻代垃圾回收-并发标记" tabindex="-1"><a class="header-anchor" href="#young-collection-concurrent-mark-年轻代垃圾回收-并发标记"><span>Young Collection + Concurrent Mark（年轻代垃圾回收+并发标记）</span></a></h4><ul><li>当老年代占用内存超过阈值（默认是45%）后，触发并发标记，这时无需暂停用户线程</li><li>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。</li><li>这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据暂停时间目标优先回收价值高（存活对象少）的区域（Garbage First）</li></ul><h4 id="mixed-collection-混合垃圾回收" tabindex="-1"><a class="header-anchor" href="#mixed-collection-混合垃圾回收"><span>Mixed Collection（混合垃圾回收）</span></a></h4><ul><li><p>混合收集阶段中，参与复制的有eden、survivor、old。<code>eden+survivor → new survivor</code>，<code>Garbage First old → new old</code></p></li><li><p>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集。</p></li></ul><h3 id="g1垃圾回收器回收过程" tabindex="-1"><a class="header-anchor" href="#g1垃圾回收器回收过程"><span>G1垃圾回收器回收过程</span></a></h3><h4 id="_1-young-gc-minor-gc" tabindex="-1"><a class="header-anchor" href="#_1-young-gc-minor-gc"><span>1. Young GC（Minor GC）</span></a></h4><ul><li>回收 Eden 区，存活对象复制到 Survivor 或 Old 区。</li><li>停顿时间短，由多个线程并行完成。</li></ul><h4 id="_2-mixed-gc" tabindex="-1"><a class="header-anchor" href="#_2-mixed-gc"><span>2. Mixed GC</span></a></h4><ul><li>在堆内存使用率达到阈值后，G1 会执行 Mixed GC。</li><li>同时回收 Young 区 和 <strong>部分 Old 区</strong>，但不是整个 Old 区。</li></ul><h4 id="_3-full-gc" tabindex="-1"><a class="header-anchor" href="#_3-full-gc"><span>3. Full GC</span></a></h4><ul><li>极少发生，只在内存耗尽或并发失败时触发。</li><li>单线程执行，耗时长（尽量避免）。</li></ul><h4 id="g1垃圾回收常用参数" tabindex="-1"><a class="header-anchor" href="#g1垃圾回收常用参数"><span>G1垃圾回收常用参数</span></a></h4><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">-XX:+UseG1GC</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                            # 启用 G1 收集器</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">-XX:MaxGCPauseMillis</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">=200</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">               # 设置最大 GC 停顿时间（目标）</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">-XX:InitiatingHeapOccupancyPercent</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">=45</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> # 触发 Mixed GC 的阈值</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">-XX:ParallelGCThreads</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">=8</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                # GC 使用的并行线程数</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">-XX:G1HeapRegionSize</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">=8m</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                # 设置每个 Region 大小</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="强引用、软引用、弱引用、虚引用的区别" tabindex="-1"><a class="header-anchor" href="#强引用、软引用、弱引用、虚引用的区别"><span>强引用、软引用、弱引用、虚引用的区别</span></a></h3><table><thead><tr><th>引用类型</th><th>回收时机</th><th>是否参与 GC 判断</th><th>典型用途</th><th>类名</th></tr></thead><tbody><tr><td><strong>强引用</strong></td><td>永不回收（除非内存不足）</td><td>❌ 不可回收</td><td>普通对象引用</td><td>无（默认引用）</td></tr><tr><td><strong>软引用</strong></td><td>内存不足时回收</td><td>✅ 优先级低</td><td>缓存（如图片、网页）</td><td><code>SoftReference</code></td></tr><tr><td><strong>弱引用</strong></td><td>GC 时立即回收（只要发现）</td><td>✅ 更易回收</td><td>ThreadLocal Map key 等弱关联数据</td><td><code>WeakReference</code></td></tr><tr><td><strong>虚引用</strong></td><td>GC 时回收，并通知 ReferenceQueue</td><td>✅ 最弱引用</td><td>清理前通知、资源释放监控</td><td><code>PhantomReference</code></td></tr></tbody></table><ol><li><strong>强引用（Strong Reference）</strong></li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Object</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> obj</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Object</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 强引用</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>JVM 不会回收该对象，除非 <code>obj</code> 设为 null。</li></ul><ol start="2"><li><strong>软引用（SoftReference）</strong></li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">SoftReference</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Object</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> softRef</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> SoftReference</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;&gt;(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Object</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>内存充足时不会被回收；内存紧张时才会被 GC。</li><li>常用于实现<strong>内存敏感缓存</strong>。</li></ul><ol start="3"><li><strong>弱引用（WeakReference）</strong></li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">WeakReference</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Object</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> weakRef</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> WeakReference</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;&gt;(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Object</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>GC 时一定会被清除，即使内存充足。</li><li>常见于 ThreadLocal、WeakHashMap。</li></ul><ol start="4"><li><strong>虚引用（PhantomReference）</strong></li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">PhantomReference</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Object</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> phantomRef</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> PhantomReference</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;&gt;(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Object</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(),</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> referenceQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>本身不会影响对象生命周期。</li><li>对象被 GC 后会进入 <code>ReferenceQueue</code>，常用于资源释放前的通知。</li></ul><h2 id="jvm实践" tabindex="-1"><a class="header-anchor" href="#jvm实践"><span>JVM实践</span></a></h2><h3 id="jvm调优的参数可以在哪里设置参数值" tabindex="-1"><a class="header-anchor" href="#jvm调优的参数可以在哪里设置参数值"><span>JVM调优的参数可以在哪里设置参数值</span></a></h3><ul><li><p>war包部署：在tomcat中设置：<code>TOMCAT_HOME/bin/catalina.sh</code>，修改<code>JAVA_OPTS=&quot;-Xms512m&quot;</code></p></li><li><p>jar包部署：在启动参数设置：<code>java -Xms512m -java xxx.jar --spring.profiles.active=prod</code></p></li></ul><h3 id="jvm调优的参数有哪些" tabindex="-1"><a class="header-anchor" href="#jvm调优的参数有哪些"><span>JVM调优的参数有哪些？</span></a></h3><blockquote><p>对于JVM调优，主要就是调整年轻代、老年代、元空间的内存空间大小及使用的垃圾回收器类型</p></blockquote><h4 id="堆内存设置" tabindex="-1"><a class="header-anchor" href="#堆内存设置"><span>堆内存设置</span></a></h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-Xms&lt;size&gt;</code></td><td>初始堆大小（建议与 <code>-Xmx</code> 相同，避免频繁扩容）</td></tr><tr><td><code>-Xmx&lt;size&gt;</code></td><td>最大堆大小（如 <code>-Xmx2g</code>）</td></tr><tr><td><code>-Xmn&lt;size&gt;</code></td><td>新生代大小（Old 为总堆减去该值）</td></tr><tr><td><code>-XX:NewRatio=n</code></td><td>老年代 / 新生代比例，如 <code>-XX:NewRatio=2</code> 表示 1/3 新生代，2/3 老年代</td></tr><tr><td><code>-XX:SurvivorRatio=n</code></td><td>Eden / Survivor 比例，默认 <code>8:1:1</code>，即 <code>-XX:SurvivorRatio=8</code></td></tr><tr><td><code>-XX:MaxMetaspaceSize=256m</code></td><td>设置元空间（类加载空间）最大值</td></tr></tbody></table><h4 id="栈内存设置" tabindex="-1"><a class="header-anchor" href="#栈内存设置"><span>栈内存设置</span></a></h4><table><thead><tr><th>参数</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><code>-Xss&lt;size&gt;</code></td><td>每个线程的栈大小</td><td>默认值：一般为 1MB（不同平台可能不同）</td></tr><tr><td><code>-XX:ThreadStackSize=n</code></td><td>设置线程栈大小（单位 KB）</td><td>与 <code>-Xss</code> 功能类似，部分 JVM 使用此参数</td></tr></tbody></table><h4 id="gc类型设置" tabindex="-1"><a class="header-anchor" href="#gc类型设置"><span>GC类型设置</span></a></h4><table><thead><tr><th>参数</th><th>垃圾收集器</th></tr></thead><tbody><tr><td><code>-XX:+UseSerialGC</code></td><td>串行回收器（小内存）</td></tr><tr><td><code>-XX:+UseParallelGC</code></td><td>吞吐量优先（默认 JDK8）</td></tr><tr><td><code>-XX:+UseConcMarkSweepGC</code></td><td>CMS，并发低延迟（JDK9 及前）</td></tr><tr><td><code>-XX:+UseG1GC</code></td><td>G1，低延迟、分区回收</td></tr><tr><td><code>-XX:+UseZGC</code>（JDK11+）</td><td>超低延迟，适合大内存</td></tr><tr><td><code>-XX:+UseShenandoahGC</code>（JDK12+）</td><td>RedHat 开发的并发收集器</td></tr></tbody></table><h4 id="gc调优参数" tabindex="-1"><a class="header-anchor" href="#gc调优参数"><span>GC调优参数</span></a></h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-XX:MaxGCPauseMillis=200</code></td><td>G1 等收集器的最大停顿时间目标（ms）</td></tr><tr><td><code>-XX:+PrintGCDetails</code></td><td>输出 GC 详细信息</td></tr><tr><td><code>-Xlog:gc*</code>（JDK9+）</td><td>GC 日志统一日志接口</td></tr><tr><td><code>-XX:+UseStringDeduplication</code></td><td>启用字符串去重（G1 专用）</td></tr><tr><td><code>-XX:+ExplicitGCInvokesConcurrent</code></td><td><code>System.gc()</code> 使用并发 GC</td></tr></tbody></table><h4 id="诊断与监控参数" tabindex="-1"><a class="header-anchor" href="#诊断与监控参数"><span>诊断与监控参数</span></a></h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-XX:+PrintGCDateStamps</code></td><td>打印 GC 时间戳</td></tr><tr><td><code>-XX:+HeapDumpOnOutOfMemoryError</code></td><td>OOM 时生成堆转储文件</td></tr><tr><td><code>-XX:HeapDumpPath=xxx.hprof</code></td><td>指定堆转储路径</td></tr><tr><td><code>-XX:+PrintFlagsFinal</code></td><td>输出所有 JVM 参数及其默认值</td></tr><tr><td><code>-XX:+UnlockDiagnosticVMOptions</code></td><td>解锁诊断参数</td></tr><tr><td><code>-XX:+PrintClassHistogramBeforeFullGC</code></td><td>打印类占用信息</td></tr><tr><td><code>-XX:+UseGCLogFileRotation</code></td><td>GC 日志滚动策略</td></tr></tbody></table><h4 id="jit-与性能相关参数" tabindex="-1"><a class="header-anchor" href="#jit-与性能相关参数"><span>JIT 与性能相关参数</span></a></h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-XX:+TieredCompilation</code></td><td>启用分层编译（默认开启）</td></tr><tr><td><code>-XX:+PrintCompilation</code></td><td>打印 JIT 编译的方法信息</td></tr><tr><td><code>-XX:CompileThreshold=10000</code></td><td>热点代码编译阈值</td></tr></tbody></table><h3 id="jvm调优工具" tabindex="-1"><a class="header-anchor" href="#jvm调优工具"><span>JVM调优工具</span></a></h3><table><thead><tr><th>工具名</th><th>功能</th><th>使用方式</th></tr></thead><tbody><tr><td><code>jps</code></td><td>列出当前 JVM 进程</td><td><code>jps -l</code> 查看完整类名</td></tr><tr><td><code>jstat</code></td><td>查看 GC、类加载、内存使用等统计信息</td><td><code>jstat -gc &lt;pid&gt;</code></td></tr><tr><td><code>jstack</code></td><td>导出线程堆栈，用于死锁/高 CPU 分析</td><td><code>jstack &lt;pid&gt;</code></td></tr><tr><td><code>jmap</code></td><td>查看内存使用、导出堆快照</td><td><code>jmap -heap</code> / <code>-dump:file=xxx.hprof</code></td></tr><tr><td><code>jinfo</code></td><td>查看/修改 JVM 参数</td><td><code>jinfo -flags &lt;pid&gt;</code></td></tr><tr><td><code>jcmd</code></td><td>综合工具，可代替上述大部分命令</td><td><code>jcmd &lt;pid&gt; help</code></td></tr><tr><td><strong>VisualVM</strong></td><td>图形界面分析 GC、堆、线程、方法耗时</td><td>需要安装，支持插件</td></tr><tr><td><strong>JConsole</strong></td><td>可视化监控内存、线程、类、MBean 等</td><td><code>jconsole</code> 启动</td></tr></tbody></table><h4 id="arthas" tabindex="-1"><a class="header-anchor" href="#arthas"><span>Arthas</span></a></h4><ul><li>下载地址：https://arthas.aliyun.com/arthas-boot.jar</li></ul><p><strong>常用命令</strong></p><ul><li>dashboard，查看面板</li><li>thread 8，定位线程问题</li><li>thread -b，查看阻塞线程原因</li><li>jad com.packge.name 反编译包</li><li>ognl 命令可以查看线上系统变量的值，甚至可以修改变量的值</li></ul><h3 id="反汇编" tabindex="-1"><a class="header-anchor" href="#反汇编"><span>反汇编</span></a></h3><p><code>javap -c main.class &gt; out.txt</code>反汇编class文件</p><h3 id="java内存泄漏的排查思路" tabindex="-1"><a class="header-anchor" href="#java内存泄漏的排查思路"><span>Java内存泄漏的排查思路</span></a></h3><ol><li>导出堆快照</li></ol><blockquote><ul><li><p>使用jmap命令获取运行中程序的dump文件</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">jmap</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -dump:live,format=b,file=heap.hprof</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">pi</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">d</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>使用vm参数获取dump文件（有的情况是内存溢出之后程序则会直接中断，而jmap只能打印在运行中的程序，所以建议通过参数的方式生成Dump文件</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">-XX:+HeapDumpOnOutOfMemoryError</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">-XX:HeapDumpPath</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">=./dump.hprof</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></blockquote><ol start="2"><li>通过工具分析<code>.hprof</code></li></ol><blockquote><ul><li>查找内存占用最多的对象：注意是否有某类对象（如 <code>ArrayList</code>, <code>HashMap</code>, <code>byte[]</code>）实例数量或内存占用异常高。</li><li>分析 GC Roots 引用链：分析为什么该对象没有被 GC 回收（被谁引用着）</li><li>查看保留堆大小（Retained Heap）：表示“删除某个对象后能释放的总内存”</li></ul></blockquote><ol start="3"><li>常见泄露特征</li></ol><table><thead><tr><th>场景</th><th>描述</th></tr></thead><tbody><tr><td><strong>静态集合</strong></td><td><code>Map</code>, <code>List</code> 为 static，被无限添加元素</td></tr><tr><td><strong>ThreadLocal</strong></td><td>未手动移除引用，导致线程无法回收</td></tr><tr><td><strong>Listener / 回调</strong></td><td>注册后未移除，如事件监听器</td></tr><tr><td><strong>缓存实现</strong></td><td>没有清理机制或使用强引用</td></tr><tr><td><strong>连接/资源未关闭</strong></td><td>未关闭 JDBC/IO/Socket，间接保留引用</td></tr><tr><td><strong>长生命周期对象持有短生命周期对象</strong></td><td>例如缓存中保留页面请求对象</td></tr></tbody></table><h3 id="cpu飙高排查方案与思路" tabindex="-1"><a class="header-anchor" href="#cpu飙高排查方案与思路"><span>CPU飙高排查方案与思路</span></a></h3><ol><li>定位占用 CPU 高的进程</li></ol><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 查看占用高的进程</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">top</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -Hp</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">java_pi</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">d</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">       # -H 显示线程</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">htop</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                     # 更直观，支持按 CPU 排序</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>找到占用高的线程（注意 Thread ID）</li></ul><ol start="2"><li>将线程 ID 转换为十六进制（用于后续匹配）</li></ol><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">printf</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">%x\\n</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">线程I</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">D</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 例如：线程 ID 为 10100，转为十六进制为 2774</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>打印线程栈信息，定位“哪段代码”导致高 CPU</li></ol><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">jstack</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">java_pi</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">d</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &gt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> jstack.log</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>在 <code>jstack.log</code> 中搜索对应的十六进制线程 ID（注意前缀补 0，如 <code>0x00002774</code>）</li><li>找到线程栈，<strong>重点看栈顶的方法调用</strong></li></ul><ol start="4"><li>常见高CPU原因</li></ol><table><thead><tr><th>原因</th><th>表现</th><th>说明</th></tr></thead><tbody><tr><td>死循环 / 频繁轮询</td><td>栈顶是循环内逻辑</td><td>CPU 被无效逻辑打满</td></tr><tr><td>大量 JSON 解析、字符串拼接</td><td>栈顶是 <code>Jackson/Gson</code>、<code>StringBuilder.append</code></td><td>CPU 密集操作</td></tr><tr><td>锁竞争（线程频繁争用）</td><td>栈中频繁有 <code>synchronized</code> / <code>ReentrantLock</code></td><td>自旋导致 CPU 高</td></tr><tr><td>GC 频繁</td><td>多为 JVM GC 线程</td><td>查看 GC 日志，分析回收情况</td></tr><tr><td>网络/IO阻塞引发反复重试</td><td>栈中有 <code>read</code> / <code>poll</code> 等</td><td>IO异常未处理</td></tr></tbody></table>`,150)]))}const p=a(l,[["render",h]]),c=JSON.parse('{"path":"/studyNotes/f8wgtf7v/","title":"面试题-JVM","lang":"zh-CN","frontmatter":{"title":"面试题-JVM","createTime":"2025/07/03 02:39:45","permalink":"/studyNotes/f8wgtf7v/"},"readingTime":{"minutes":18.18,"words":5454},"git":{"updatedTime":1749436914000,"contributors":[{"name":"Lang","username":"Lang","email":"914551901@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/Lang?v=4","url":"https://github.com/Lang"}]},"filePathRelative":"notes/学习笔记/八股文/面试题-JVM.md","headers":[]}');export{p as comp,c as data};
