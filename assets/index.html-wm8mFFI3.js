import{_ as r,c as n,b as t,o as a}from"./app-dsZ4C4U9.js";const o={};function l(i,e){return a(),n("div",null,e[0]||(e[0]=[t("p",null,"面试官您好，我叫郎瑞峰，是河北工业大学人工智能专业的硕士研究生，研究方向是智慧教育与工业创新。自2023年入学以来，我一直在负责主导开发了“DeepEdu智慧教育评价系统”，基于国家十大育人体系和三全育人政策，构建了完整的微服务架构，目前已在多所高校上线并持续迭代更新。在项目中，我担任项目负责人及后端开发工程师，负责系统架构设计、需求分析、数据库设计与运维支持。基于此回收的数据，我还利用大模型+SpringAI开发了一个专家系统，名为辅导员助手，可以为辅导员提供一键分析学生成绩、学生信息等功能。在学校我还担任学院内的党支部书记，负责党务相关的事宜。本科的时候我还担任学校大型门户网站的站长，负责带领团队开发和维护学校部分网站。我的自我介绍完毕，请您点评。",-1),t("p",null,"当时是由于系统上各种表的CRUD太多，代码过于重复，导致开发效率低下。于是我想到了封装MyBatis-Plus的方法，最开始只是设置了BaseController和BaseService，这样只需要业务表的Controller继承自BaseController就能够自动拥有增删改查的接口，但后来发现这样会导致类爆炸的问题，业务表太多导致Controller过多。于是我设计了动态代理的方式去动态生成Controller并注册到Spring HandlerMapping中，具体实现流程是这样的，首先设计一个AutoApi的注解，注解可以指定path路径，动态代理类实现了Spring的监听接口，在Spring广播了上下文刷新事件后进行执行，这个时候Spring的Bean都已经准备好了。我通过扫描基础包，去获取带了AutoApi注解的实体类，然后通过ByteBuddy去动态创建一个AutoApiController类继承BaseController，通过服务发现和反射机制注入Service和entity，然后添加到Spring的Bean容器中，最后通过反射调用SpringMVC的detectHandlerMethods方法，将将Controller方法注册为 Handler，映射到 Spring MVC 的 HandlerMapping 中。从而实现了只需要在实体类上加一个AutoApi注解，即可自动产生RESTful API的功能。另外我还封装了统一的分页管理器，以及统一的响应包，统一的异常处理。大大提高了团队开发效率。",-1)]))}const p=r(o,[["render",l]]),u=JSON.parse('{"path":"/studyNotes/xvaxupu0/","title":"自我介绍","lang":"zh-CN","frontmatter":{"title":"自我介绍","createTime":"2025/07/03 02:39:45","permalink":"/studyNotes/xvaxupu0/"},"readingTime":{"minutes":2.23,"words":670},"git":{"updatedTime":1751507580000,"contributors":[{"name":"Lang","username":"Lang","email":"914551901@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/Lang?v=4","url":"https://github.com/Lang"}]},"filePathRelative":"notes/学习笔记/八股文/自我介绍.md","headers":[]}');export{p as comp,u as data};
