import{_ as n,c as t,a as r,o}from"./app-dsZ4C4U9.js";const s={};function a(e,p){return o(),t("div",null,p[0]||(p[0]=[r('<h2 id="计算机基础" tabindex="-1"><a class="header-anchor" href="#计算机基础"><span>计算机基础</span></a></h2><p><strong>Q: TCP 三次握手和四次挥手过程是什么？</strong></p><p>A: 三次握手用于建立连接：</p><ol><li>客户端发送 SYN 报文，进入 SYN_SEND 状态。</li><li>服务器响应 SYN+ACK 报文，进入 SYN_RECV。</li><li>客户端收到后发送 ACK，进入 ESTABLISHED，服务器收到后也进入 ESTABLISHED。 四次挥手用于断开连接：</li><li>客户端发送 FIN，请求关闭，进入 FIN_WAIT_1。</li><li>服务器确认 ACK，进入 CLOSE_WAIT，客户端进入 FIN_WAIT_2。</li><li>服务器发送 FIN，进入 LAST_ACK。</li><li>客户端回复 ACK，进入 TIME_WAIT，服务器关闭，客户端稍后关闭。</li></ol><p><strong>Q: HTTP 和 HTTPS 有什么区别？</strong></p><p>A: HTTP 是明文传输，HTTPS 使用 TLS/SSL 加密通信，更安全。HTTPS 需要证书，能防止中间人攻击和窃听。</p><p><strong>Q: 进程和线程的区别？</strong></p><p>A: 进程是资源分配的基本单位，线程是调度的基本单位。一个进程可以包含多个线程，线程共享内存空间，进程间不共享。</p><p><strong>Q: 什么是死锁？如何避免？</strong></p><p>A: 多个线程互相等待对方释放资源导致的僵局。避免方法有：资源有序分配、加锁顺序一致、使用 tryLock、合理设置超时等。</p><h2 id="java-基础" tabindex="-1"><a class="header-anchor" href="#java-基础"><span>Java 基础</span></a></h2><p><strong>Q: HashMap 的底层实现原理是什么？</strong></p><p>A: 基于数组 + 链表 + 红黑树，JDK 8 后链表长度超过阈值转红黑树，提高查询效率。</p><p><strong>Q: Java 中反射的使用场景和原理？</strong></p><p>A: 运行时动态获取类的信息并调用其属性或方法，常用于框架如 Spring、ORM 实现。通过 <code>Class.forName()</code>、<code>getDeclaredMethod()</code> 实现。</p><p><strong>Q: 类加载机制包括哪些步骤？</strong></p><p>A: 包括：加载、验证、准备、解析、初始化、使用、卸载。由类加载器完成，遵循双亲委派机制。</p><h2 id="并发编程" tabindex="-1"><a class="header-anchor" href="#并发编程"><span>并发编程</span></a></h2><p><strong>Q: ReentrantLock 和 synchronized 有什么区别？</strong></p><p>A: ReentrantLock 是显示加锁，可中断、限时、公平；synchronized 是隐式锁，JVM 管理。</p><p><strong>Q: volatile 关键字的作用是什么？</strong></p><p>A: 保证变量的可见性和禁止指令重排序，不保证原子性。</p><p><strong>Q: CAS 是什么？如何解决 ABA 问题？</strong></p><p>A: Compare-And-Swap，是原子操作。ABA 问题通过加版本号或使用 <code>AtomicStampedReference</code> 解决。</p><p><strong>Q: ThreadLocal 的原理及应用场景？</strong></p><p>A: 为每个线程维护一份变量副本，适用于线程隔离，如数据库连接、用户信息上下文。</p><p><strong>Q: Java 线程池的工作原理？核心参数有哪些？</strong></p><p>A: 线程池使用阻塞队列存储任务，核心线程处理任务，最大线程控制数量。主要参数：corePoolSize, maximumPoolSize, keepAliveTime, workQueue。</p><h2 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm"><span>JVM</span></a></h2><p><strong>Q: JVM 内存结构包括哪些区域？</strong></p><p>A: 包括方法区、堆、虚拟机栈、本地方法栈、程序计数器。</p><p><strong>Q: 类的生命周期是怎样的？</strong></p><p>A: 加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载。</p><p><strong>Q: 什么是双亲委派机制？</strong></p><p>A: 类加载器优先让父加载器加载，避免类重复加载，确保核心类安全。</p><p><strong>Q: CMS 和 G1 垃圾回收器的特点和使用场景？</strong></p><p>A: CMS 并发收集、低停顿，适合响应快场景；G1 分区回收、可预测停顿，适合大内存应用。</p><h2 id="spring-boot" tabindex="-1"><a class="header-anchor" href="#spring-boot"><span>Spring Boot</span></a></h2><p><strong>Q: Spring 的 IOC 容器如何实现依赖注入？</strong></p><p>A: 通过 BeanFactory 或 ApplicationContext，根据注解或 XML 自动装配依赖。</p><p><strong>Q: AOP 的实现原理？</strong></p><p>A: 基于动态代理（JDK 或 CGLIB），通过切面织入增强逻辑。</p><p><strong>Q: Spring Bean 的生命周期？</strong></p><p>A: 实例化 -&gt; 设置属性 -&gt; 初始化（@PostConstruct）-&gt; 使用 -&gt; 销毁（@PreDestroy）。</p><p><strong>Q: 什么是循环依赖？Spring 如何处理？</strong></p><p>A: A 依赖 B，B 依赖 A。Spring 通过三级缓存提前暴露 bean 实例解决构造器注入的循环依赖。</p><p><strong>Q: Spring Boot 的自动配置原理？</strong></p><p>A: 基于 <code>@EnableAutoConfiguration</code> 和 SPI 机制，自动加载配置类，结合条件注解生效。</p><h2 id="spring-ai" tabindex="-1"><a class="header-anchor" href="#spring-ai"><span>Spring AI</span></a></h2><p><strong>Q: 什么是 Function Calling？如何在 Spring AI 中使用？</strong></p><p>A: Function Calling 是调用模型定义的函数，Spring AI 通过 DSL 或注解注册调用本地或远程函数。</p><p><strong>Q: RAG 检索增强生成的流程？</strong></p><p>A: Query -&gt; 检索向量库获取文档 -&gt; 与 Prompt 合并 -&gt; 输入 LLM -&gt; 返回答案。</p><p><strong>Q: Spring AI 如何集成向量数据库？</strong></p><p>A: 通过配置 Embedding 模型和向量存储实现，如支持 Qdrant、Milvus、Faiss 等。</p><h2 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql"><span>MySQL</span></a></h2><p><strong>Q: 事务的四大特性（ACID）是什么？</strong></p><p>A: 原子性、一致性、隔离性、持久性。</p><p><strong>Q: MVCC 是如何实现的？</strong></p><p>A: 多版本并发控制，依赖 undo log 和隐藏字段版本号，快照读实现非锁并发。</p><p><strong>Q: 什么情况下使用联合索引？</strong></p><p>A: 多个字段同时查询且有顺序要求时，提高查询效率。</p><p><strong>Q: MySQL 的锁机制有哪些类型？</strong></p><p>A: 包括表锁、行锁；行锁又分为共享锁、排他锁；还有意向锁、Gap 锁等。</p><p><strong>Q: MySQL 中 binlog、redo log 和 undo log 的作用？</strong></p><p>A: binlog 用于主从同步和恢复；redo 保证崩溃恢复；undo 用于回滚和 MVCC。</p><h2 id="redis" tabindex="-1"><a class="header-anchor" href="#redis"><span>Redis</span></a></h2><p><strong>Q: Redis 常用数据类型及应用场景？</strong></p><p>A: String（缓存）、Hash（对象存储）、List（队列）、Set（去重）、ZSet（排行榜）。</p><p><strong>Q: Redis 是单线程的吗？为什么这么快？</strong></p><p>A: 是的。基于内存、无上下文切换、IO 多路复用，使其高性能。</p><p><strong>Q: RDB 和 AOF 有什么区别？</strong></p><p>A: RDB 是快照持久化，定时触发；AOF 是日志持久化，记录每条命令，恢复更完整。</p><p><strong>Q: 缓存穿透、击穿、雪崩如何处理？</strong></p><p>A: 穿透：布隆过滤器；击穿：加互斥锁；雪崩：设置随机过期、降级限流。</p><p><strong>Q: Redis Sentinel 与集群模式的区别？</strong></p><p>A: Sentinel 仅主从切换，适合小规模；Cluster 支持分片、扩容，适合大规模分布式部署。</p><h2 id="rabbitmq" tabindex="-1"><a class="header-anchor" href="#rabbitmq"><span>RabbitMQ</span></a></h2><p><strong>Q: RabbitMQ 的核心架构有哪些组件？</strong></p><p>A: Producer、Exchange、Queue、Binding、Consumer。</p><p><strong>Q: 如何实现消息确认与可靠性传输？</strong></p><p>A: 使用 confirm 确认机制、事务机制、ACK 确认和重试机制等。</p><p><strong>Q: 什么是延迟队列？如何实现？</strong></p><p>A: 延迟消息定时投递，可通过 TTL + 死信队列或插件实现。</p><p><strong>Q: RabbitMQ 如何实现高可用？</strong></p><p>A: 通过镜像队列（HA），集群部署，节点间同步保证服务不中断。</p><h2 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式"><span>设计模式</span></a></h2><p><strong>Q: 单例模式有哪些实现方式？线程安全吗？</strong></p><p>A: 饿汉式（线程安全）、懒汉式加锁、双重检查锁、静态内部类。</p><p><strong>Q: 策略模式的应用场景是什么？</strong></p><p>A: 不同策略动态切换，如支付方式、排序算法、权限处理等。</p><p><strong>Q: 模板方法模式与策略模式的区别？</strong></p><p>A: 模板定义流程，子类实现；策略封装算法，运行时决定。</p><p><strong>Q: 责任链模式如何实现？有哪些应用？</strong></p><p>A: 每个处理器有指向下一个的引用，依次处理。应用如日志处理、审批流程等。</p>',95)]))}const i=n(s,[["render",a]]),A=JSON.parse('{"path":"/studyNotes/3majfggu/","title":"技能面试问题清单","lang":"zh-CN","frontmatter":{"title":"技能面试问题清单","createTime":"2025/07/03 02:39:45","permalink":"/studyNotes/3majfggu/"},"readingTime":{"minutes":5.86,"words":1759},"git":{"updatedTime":1751507580000,"contributors":[{"name":"Lang","username":"Lang","email":"914551901@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/Lang?v=4","url":"https://github.com/Lang"}]},"filePathRelative":"notes/学习笔记/八股文/技能面试问题清单.md","headers":[]}');export{i as comp,A as data};
