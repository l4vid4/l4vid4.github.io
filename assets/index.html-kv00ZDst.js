import{_ as i,c as o,a as t,o as l}from"./app-dsZ4C4U9.js";const n={};function r(s,e){return l(),o("div",null,e[0]||(e[0]=[t('<p>[TOC]</p><h2 id="智慧教育系统" tabindex="-1"><a class="header-anchor" href="#智慧教育系统"><span>智慧教育系统</span></a></h2><h3 id="你在-智慧教育系统-中提到了-clickhouse-的使用-能详细讲讲你是如何提升查询性能的吗-有哪些具体优化手段" tabindex="-1"><a class="header-anchor" href="#你在-智慧教育系统-中提到了-clickhouse-的使用-能详细讲讲你是如何提升查询性能的吗-有哪些具体优化手段"><span>你在“智慧教育系统”中提到了 ClickHouse 的使用，能详细讲讲你是如何提升查询性能的吗？有哪些具体优化手段？</span></a></h3><p>原本学生行为数据存储在 Hadoop + Hive 中，面对复杂画像查询时性能瓶颈明显，甚至几十秒以上。尝试 Spark on Hive 后因兼容性和部署成本放弃。</p><p>最终我主导将数据迁移至 ClickHouse，主要优化点有：</p><ol><li><strong>按学年、学院等维度设计分区键</strong>，结合 MergeTree 引擎，大幅减少扫描范围；</li><li>采用 <strong>宽表模型+列式存储</strong>，一次查询命中多个标签字段，降低关联开销；</li><li>接入 <strong>Redis 缓存热点查询</strong>结果，并通过参数控制缓存过期时间；</li><li>在接口层封装 SQL 构造器，支持按条件灵活组合维度并安全拼接 SQL，防止注入。</li><li>ClickHouse本身就采用向量化查询方式，利用CPU多核去执行查询语句</li></ol><p>最终将原查询时间从几十秒压缩至 100ms 以内，满足了实时画像与动态分群的业务需求。</p><h3 id="你提到在-智慧教育系统-中设计了一个-灵活可扩展的动态分群模块-并通过-规则抽象与-sql-构建引擎-实现了任意维度组合条件。请你详细讲讲这个模块的技术设计、使用场景-以及你是如何解决性能与可维护性问题的" tabindex="-1"><a class="header-anchor" href="#你提到在-智慧教育系统-中设计了一个-灵活可扩展的动态分群模块-并通过-规则抽象与-sql-构建引擎-实现了任意维度组合条件。请你详细讲讲这个模块的技术设计、使用场景-以及你是如何解决性能与可维护性问题的"><span>你提到在“智慧教育系统”中设计了一个“灵活可扩展的动态分群模块”，并通过“规则抽象与 SQL 构建引擎”实现了任意维度组合条件。请你详细讲讲这个模块的技术设计、使用场景，以及你是如何解决性能与可维护性问题的？</span></a></h3><p>在学生画像模块中，我们需要支持按多种维度对学生进行灵活分群，比如：性别=男、成绩&gt;85、近30天登录次数&gt;10等。为实现这一目标，我设计了一个动态分群引擎，核心思路是将“条件规则”从代码中抽离，结构化存储并动态执行。</p><p>我是这样做的。首先，将学生属性（基本、行为、标签）进行结构化建模，每个条件抽象为一条“规则项”，规则支持字段名、操作符、值、逻辑连接等信息，支持嵌套表达式。前端传递组合规则 JSON，我们解析成逻辑表达式树，同时将规则存入数据库，便于审计与复用。服务端将规则表达式树转换为 SQL 语句，使用安全拼接和参数绑定，避免 SQL 注入问题。使用 ClickHouse 高性能列式存储和并行计算能力执行查询，并支持分页与缓存，加快响应速度。</p><h3 id="你在项目中设计并实现了-基于注解-aop-数据库-的数据权限控制系统-请详细讲讲设计思路-怎么做到-业务代码零侵入" tabindex="-1"><a class="header-anchor" href="#你在项目中设计并实现了-基于注解-aop-数据库-的数据权限控制系统-请详细讲讲设计思路-怎么做到-业务代码零侵入"><span>你在项目中设计并实现了“基于注解 + AOP + 数据库”的数据权限控制系统，请详细讲讲设计思路，怎么做到“业务代码零侵入”？</span></a></h3><blockquote><p>我在项目中设计了基于注解 + AOP 的数据权限框架，目标是实现“零侵入”的数据访问控制。整体流程如下：</p><ol><li><strong>权限模型设计</strong>：在数据库中定义权限维度（全部、本部门、本人、自定义），用户与角色关联，角色对应不同的数据访问规则。</li><li><strong>自定义注解 <code>@DataScope</code></strong>：用于标注需要数据权限控制的方法，并配置控制维度字段（如部门ID字段、用户ID字段）；</li><li><strong>AOP 切面处理</strong>：在方法执行前，解析注解，获取当前用户的角色信息，然后在 MyBatis 的查询条件中<strong>动态注入数据范围 SQL 片段</strong>（如 <code>AND dept_id IN (...)</code>），从源头限制查询数据；</li><li><strong>SQL 拼接安全性</strong>：所有 SQL 条件拼接使用参数绑定避免注入风险，注解参数控制是否启用数据权限；</li><li><strong>业务无感知</strong>：控制逻辑集中在 AOP 层，业务代码无需关心数据范围，保证模块解耦。</li></ol><p>举例：查询学生数据时，拥有“本部门数据”权限的用户只会查到其所在学院的学生记录。</p></blockquote><blockquote><p>最终实现了按用户、角色、部门多个维度精细化控制，同时兼顾安全性与可维护性。</p></blockquote><h3 id="你在-智慧教育系统-中提到了微服务架构-假如让你从零开始设计这样一个系统-请问你会如何划分微服务-服务之间如何通信-如何保证系统的稳定性与扩展性" tabindex="-1"><a class="header-anchor" href="#你在-智慧教育系统-中提到了微服务架构-假如让你从零开始设计这样一个系统-请问你会如何划分微服务-服务之间如何通信-如何保证系统的稳定性与扩展性"><span>你在“智慧教育系统”中提到了微服务架构，假如让你从零开始设计这样一个系统，请问你会如何划分微服务？服务之间如何通信？如何保证系统的稳定性与扩展性？</span></a></h3><p>智慧教育系统采用微服务架构，我们从<strong>领域驱动设计</strong>出发，结合实际九大职责与十大育人模块进行模块拆分。服务大致包括：</p><ul><li><strong>用户服务</strong>：统一身份认证（SSO）、学生/教师基本信息管理</li><li><strong>权限服务</strong>：基于角色的数据访问控制（集成 Shiro）</li><li><strong>工作流服务</strong>：基于 Activiti 处理审批流配置与节点执行</li><li><strong>画像服务</strong>：处理标签建模、分群逻辑与行为采集分析</li><li><strong>文件服务</strong>：提供统一上传、预览、存储管理（基于 MinIO）</li><li><strong>九大职责服务</strong>：分别对应辅导员日常工作的各个子系统</li><li><strong>网关服务</strong>：统一入口，负责路由、鉴权、限流等</li></ul><h3 id="你提到在项目中处理过缓存穿透、缓存雪崩等问题-请你详细讲讲这两种问题是怎么发生的-你是如何应对和优化的" tabindex="-1"><a class="header-anchor" href="#你提到在项目中处理过缓存穿透、缓存雪崩等问题-请你详细讲讲这两种问题是怎么发生的-你是如何应对和优化的"><span>你提到在项目中处理过缓存穿透、缓存雪崩等问题，请你详细讲讲这两种问题是怎么发生的，你是如何应对和优化的？</span></a></h3><p>在实际项目中，我们遇到了 <strong>缓存穿透</strong> 和 <strong>缓存雪崩</strong> 两类问题，分别是这样应对的：</p><p><strong>一、缓存穿透：</strong></p><ul><li>问题背景：某些画像在测试后被老师删除，数据库和 Redis 都无记录，但页面未刷新，导致不断请求该画像 ID，频繁打到数据库；</li><li>处理措施： <ol><li>查询数据库返回 <code>null</code> 时，也将该空值缓存（短 TTL，如 2 分钟）；</li><li>后续补充了用户行为限流 + 布隆过滤器，用于快速判断 ID 是否存在；</li></ol></li></ul><p><strong>二、缓存雪崩：</strong></p><ul><li>问题背景：Redis 单节点宕机，正值毕业季高峰，大量请求击穿缓存直接压垮数据库；</li><li>处理措施： <ol><li>排查并恢复 Redis 服务器；</li><li>后续上线 Redis Cluster，实现多节点主从 + 哨兵故障转移；</li><li>设置热点 Key 过期时间随机化（TTL 加随机数）避免同一时间大量缓存失效；</li><li>引入限流与降级机制，防止高并发直接打穿数据库；</li></ol></li></ul><h3 id="你在简历中提到了-数据库建模、索引优化、sql-调优-的经验-能不能举一个你实际优化-sql-性能的例子-你是怎么定位问题、如何优化的" tabindex="-1"><a class="header-anchor" href="#你在简历中提到了-数据库建模、索引优化、sql-调优-的经验-能不能举一个你实际优化-sql-性能的例子-你是怎么定位问题、如何优化的"><span>你在简历中提到了“数据库建模、索引优化、SQL 调优”的经验，能不能举一个你实际优化 SQL 性能的例子？你是怎么定位问题、如何优化的？</span></a></h3><p>在智慧教育系统中，学生表是访问最频繁的表之一，尤其是通过学号查询单个学生信息。在使用过程中我们发现：</p><ul><li>某些查询语句响应时间超过 1 秒，影响用户体验；</li><li>使用 <code>EXPLAIN</code> 分析发现，原语句未走索引，采用的是全表扫描（type = ALL）；</li></ul><p><strong>优化过程如下：</strong></p><ol><li>在 <code>stu_number</code>（学号）字段上建立 <strong>唯一索引</strong>，因为学号是唯一且高频检索字段；</li><li>为一些复杂查询创建了 <strong>覆盖索引</strong>（如联合索引 <code>(stu_number, status)</code>），避免回表；</li><li>为按时间范围查询的数据添加 <strong>组合索引+分区表设计</strong>，提升批量处理效率；</li><li>优化后的查询 <code>type</code> 显示为 <code>const</code> 或 <code>ref</code>，<strong>响应时间从秒级降至毫秒级</strong>；</li></ol><p>此外，我们还建立了慢查询日志定期分析机制，结合 SQL 审核工具（如 SQLAdvisor）进行持续优化。</p><h3 id="你在智慧教育系统中使用了-activiti-工作流-请问你是如何设计和使用它的-怎么实现流程的灵活配置而不修改代码" tabindex="-1"><a class="header-anchor" href="#你在智慧教育系统中使用了-activiti-工作流-请问你是如何设计和使用它的-怎么实现流程的灵活配置而不修改代码"><span>你在智慧教育系统中使用了 Activiti 工作流，请问你是如何设计和使用它的？怎么实现流程的灵活配置而不修改代码？</span></a></h3><p>在智慧教育系统中，我们使用 Activiti 实现审批流管理，目标是支持不同业务模块灵活配置流程、动态绑定、无需改动代码。整体设计如下：</p><p><strong>1. 前端建模：</strong></p><ul><li>前端通过可视化建模工具（如 Flowable Editor）创建流程图，可设置流程节点、审批人、条件表达式等；</li><li>完成后导出 BPMN 文件，上传至后端；</li></ul><p><strong>2. 流程部署与绑定：</strong></p><ul><li>后端使用 Activiti 的 <code>RepositoryService</code> 动态部署 BPMN 文件；</li><li>使用枚举类标识业务类型（如“请假流程”、“画像审批”），流程定义与业务表通过 <code>businessKey</code> 绑定；</li></ul><p><strong>3. 动态流程启动与控制：</strong></p><ul><li>业务调用 <code>RuntimeService.startProcessInstanceByKey()</code> 启动流程；</li><li>使用流程变量传递审批人、条件数据，控制流程分支；</li><li>每个节点完成后触发监听器，调用业务逻辑（如状态变更、通知等）；</li></ul><p><strong>4. 可扩展设计：</strong></p><ul><li>BPMN 模型和审批人等配置均持久化至数据库，支持业务侧配置无需改动流程图；</li><li>异常节点支持挂起、恢复、跳转，保障流程可靠性；</li></ul><p>最终实现了<strong>流程与业务解耦、按需配置、快速响应业务变更</strong>的目标。</p><h3 id="你提到-封装了-mybatis-plus-通用接口组件-统一开发规范-请具体讲讲这个组件是怎么设计的-封装了哪些功能-怎么提升了团队协同效率" tabindex="-1"><a class="header-anchor" href="#你提到-封装了-mybatis-plus-通用接口组件-统一开发规范-请具体讲讲这个组件是怎么设计的-封装了哪些功能-怎么提升了团队协同效率"><span>你提到“封装了 MyBatis-Plus 通用接口组件，统一开发规范”，请具体讲讲这个组件是怎么设计的？封装了哪些功能？怎么提升了团队协同效率？</span></a></h3><p>当时是由于系统上各种表的CRUD太多，代码过于重复，导致开发效率低下。于是我想到了封装MyBatis-Plus的方法，最开始只是设置了BaseController和BaseService，这样只需要业务表的Controller继承自BaseController就能够自动拥有增删改查的接口，但后来发现这样会导致类爆炸的问题，业务表太多导致Controller过多。于是我设计了动态代理的方式去动态生成Controller并注册到Spring HandlerMapping中，具体实现流程是这样的，首先设计一个AutoApi的注解，注解可以指定path路径，动态代理类实现了Spring的监听接口，在Spring广播了上下文刷新事件后进行执行，这个时候Spring的Bean都已经准备好了。我通过扫描基础包，去获取带了AutoApi注解的实体类，然后通过ByteBuddy去动态创建一个AutoApiController类继承BaseController，通过服务发现和反射机制注入Service和entity，然后添加到Spring的Bean容器中，最后通过反射调用SpringMVC的detectHandlerMethods方法，将将Controller方法注册为 Handler，映射到 Spring MVC 的 HandlerMapping 中。从而实现了只需要在实体类上加一个AutoApi注解，即可自动产生RESTful API的功能。另外我还封装了统一的分页管理器，以及统一的响应包，统一的异常处理。大大提高了团队开发效率。</p><h2 id="mybatis-plus-kit" tabindex="-1"><a class="header-anchor" href="#mybatis-plus-kit"><span>MyBatis-Plus-Kit</span></a></h2><h3 id="这个组件是如何实现自动生成接口的" tabindex="-1"><a class="header-anchor" href="#这个组件是如何实现自动生成接口的"><span>这个组件是如何实现自动生成接口的</span></a></h3><blockquote><p>首先动态代理类实现ApplicationListener&lt;ContextRefreshedEvent&gt;监听上下文刷新事件，使得动态代理在Spring容器准备完成后开始执行。</p></blockquote><ol><li>在指定的basePackage中扫描所有带AutoApi注解的实体类，且mode为Proxy，作为接口生成的目标对象。</li><li>使用ByteBuddy动态创建RestController类：①继承BaseController获得CRUD能力；②添加@RestController和@RequestMapping注解。③动态生成类名：AutoApi{EntityName}Controller</li><li>通过服务发现和反射机制注入Service类和实体类，并将实例注册为Spring单例Bean。</li><li>手动调用Spring MVC的内部方法detectHandlerMethods，使动态生成的控制器能处理Http请求。</li></ol><p>我开发的 MyBatis-Plus-Kit 组件中，提供了一个 <code>@AutoApi</code> 注解驱动的能力，可以实现对实体类自动生成并注册对应的API接口。这个能力的核心是动态生成 Controller 类并将其注册到 Spring MVC 的映射机制中。我阅读了 SpringMVC 的源码，了解到 <code>RequestMappingHandlerMapping</code> 是核心的 Handler 注册组件，其 <code>detectHandlerMethods()</code> 方法负责扫描 Bean 中的 <code>@RequestMapping</code> 方法并建立URL到方法的映射。因此我实现了一个 ApplicationListener&lt;ContextRefreshedEvent&gt;<code>接口，在 Spring 容器启动完成后，通过 </code>ClassPathScanningCandidateComponentProvider<code>扫描带有</code>@AutoApi<code>注解的实体类。在匹配到注解且符合 PROXY 模式的前提下，我使用 ByteBuddy 动态生成一个继承自 BaseController 的类，并在类上加上</code>@RestController<code>与</code>@RequestMapping<code>注解。随后，我通过 Spring 的</code>DefaultListableBeanFactory<code>将这个类注册为一个 Singleton Bean，并通过反射注入对应的 Service 实例和实体类的</code>Class<code>类型。同时，为了让 Spring MVC 感知这个运行时注册的 Controller，我反射调用了</code>AbstractHandlerMethodMapping.detectHandlerMethods()<code>方法手动触发 URL 映射建立。这样，整个流程无需开发者手动写 Controller，只需在实体类上加注解即可生成完整的 API。我还设计了一个</code>ServiceResolver` 工具类，支持按命名约定或注解参数解析 Service，提升了兼容性和可维护性。整个实现过程中涉及对 Spring Bean 生命周期、Spring MVC 映射机制、ByteBuddy 字节码生成技术的深入理解与综合运用，实现了低侵入、高扩展的自动 API 注册机制。这个设计目标是为了让 MyBatis-Plus 更加工程化、开箱即用，简化后端接口开发的重复工作。</p><h3 id="你觉得你的设计还有什么问题吗" tabindex="-1"><a class="header-anchor" href="#你觉得你的设计还有什么问题吗"><span>你觉得你的设计还有什么问题吗</span></a></h3><ol><li>由于是动态注册的Bean，所以可能会导致调试困难。</li><li>由于Spring生命周期的问题，可能会导致AOP切面不生效，</li></ol><blockquote><p>Spring生命周期：</p><ol><li>BeanDefinition加载阶段：包扫描、注解处理、创建BeanDefinition</li><li>Bean实例化阶段：创建Bean实例，并注入依赖（构造函数、@Autowired）</li><li>Bean初始化阶段：执行 <code>InitializingBean.afterPropertiesSet()</code>、<code>@PostConstruct</code></li><li>容器刷新阶段：<code>ApplicationContext</code> 执行 <code>refresh()</code>，初始化 Web 框架核心组件（如 DispatcherServlet、HandlerMapping）</li><li>事件广播阶段：广播 <code>ContextRefreshedEvent</code></li><li>容器就绪阶段</li></ol></blockquote>',49)]))}const d=i(n,[["render",r]]),p=JSON.parse('{"path":"/studyNotes/uznnldrg/","title":"面试题-项目","lang":"zh-CN","frontmatter":{"title":"面试题-项目","createTime":"2025/07/03 02:39:45","permalink":"/studyNotes/uznnldrg/"},"readingTime":{"minutes":11.5,"words":3451},"git":{"updatedTime":1751509922000,"contributors":[{"name":"Lang","username":"Lang","email":"914551901@qq.com","commits":3,"avatar":"https://avatars.githubusercontent.com/Lang?v=4","url":"https://github.com/Lang"}]},"filePathRelative":"notes/学习笔记/八股文/面试题-项目.md","headers":[]}');export{d as comp,p as data};
