import{_ as i,c as a,a as e,o as l}from"./app-dsZ4C4U9.js";const t="/assets/image-20250604161114820-C-PMUE_N.png",n={};function d(h,s){return l(),a("div",null,s[0]||(s[0]=[e(`<p>[TOC]</p><h2 id="_1-缓存穿透" tabindex="-1"><a class="header-anchor" href="#_1-缓存穿透"><span>1. 缓存穿透</span></a></h2><blockquote><p><strong>缓存穿透</strong>是指：<strong>请求的数据在缓存（如 Redis）和数据库中都不存在，导致每次请求都会穿过缓存直接请求数据库</strong>，从而失去了缓存的意义，严重时可能压垮数据库。</p></blockquote><h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h3><h4 id="_1-缓存空值" tabindex="-1"><a class="header-anchor" href="#_1-缓存空值"><span>1. 缓存空值</span></a></h4><ul><li><p>即：对于查询结果为 <code>null</code> 的数据，也写入缓存。</p></li><li><p>示例：</p><div class="language-redis line-numbers-mode" data-highlighter="shiki" data-ext="redis" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SET user:999999 null EX 300</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>设置一个较短的过期时间，避免缓存占用过多空间。</p></li></ul><blockquote><p>缺点：可能消耗内存，或造成数据不一致的问题。</p></blockquote><h4 id="_2-布隆过滤器-bloom-filter" tabindex="-1"><a class="header-anchor" href="#_2-布隆过滤器-bloom-filter"><span>2. 布隆过滤器（Bloom Filter）</span></a></h4><ul><li>在访问缓存之前，先用布隆过滤器判断 key 是否可能存在；</li><li>若布隆过滤器判断为“不存在”，就直接拦截请求；</li><li>优点：占用空间小，性能高；</li><li>缺点：有<strong>误判率</strong>（可能判断存在，但实际不存在）。</li></ul><blockquote><p><strong>布隆过滤器</strong></p><ul><li>采用bitmap（位图）数组。</li><li>存储数据：id为1的数据，通过多个hash函数获取hash值，根据hash计算数组对应位置改为1。</li><li>查询数据：使用相同hash函数获取hash值，判断对应位置是否都为1。</li><li>误判率可以在初始化时手动设置，一般为0.05.</li></ul></blockquote><h4 id="_3-参数校验" tabindex="-1"><a class="header-anchor" href="#_3-参数校验"><span>3. 参数校验</span></a></h4><ul><li>对传入的参数（如 ID）进行格式校验；</li><li>非法参数直接拒绝请求，不查询缓存或数据库。</li></ul><h4 id="_4-接口限流与验证码" tabindex="-1"><a class="header-anchor" href="#_4-接口限流与验证码"><span>4. 接口限流与验证码</span></a></h4><ul><li>对频繁请求的 IP 或用户加限制；</li><li>对可疑请求增加验证码验证，避免恶意攻击。</li></ul><h2 id="_2-缓存击穿" tabindex="-1"><a class="header-anchor" href="#_2-缓存击穿"><span>2. 缓存击穿</span></a></h2><blockquote><p><strong>缓存击穿</strong>是指：某个热点数据在缓存中失效（过期）的一瞬间，有大量并发请求同时访问该数据，由于缓存没有命中，导致这些请求都直接访问数据库，造成数据库压力剧增甚至宕机。</p></blockquote><h3 id="解决方案-1" tabindex="-1"><a class="header-anchor" href="#解决方案-1"><span>解决方案</span></a></h3><h4 id="_1-设置热点数据永不过期-或很长过期时间" tabindex="-1"><a class="header-anchor" href="#_1-设置热点数据永不过期-或很长过期时间"><span>1. 设置热点数据永不过期（或很长过期时间）</span></a></h4><ul><li>对于访问频繁的数据，可以设置较长 TTL，甚至不设过期时间；</li><li>由后台程序定期更新缓存，而不是自动失效。</li></ul><h4 id="_2-使用互斥锁-如分布式锁" tabindex="-1"><a class="header-anchor" href="#_2-使用互斥锁-如分布式锁"><span>2. 使用互斥锁（如分布式锁）</span></a></h4><blockquote><p>特点：强一致，性能差</p></blockquote><ul><li><p>当缓存失效时，<strong>只有一个线程能去加载数据库并回填缓存</strong>；</p></li><li><p>其余线程等待或短时间重试，防止并发访问数据库；</p></li><li><p>示例伪代码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">redis</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ==</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">acquireLock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        value </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> queryDatabase</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        redis</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">set</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ttl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">        releaseLock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> else</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">        sleep</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">50ms</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">        retry</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="_3-利用异步更新-逻辑过期" tabindex="-1"><a class="header-anchor" href="#_3-利用异步更新-逻辑过期"><span>3. 利用异步更新 + 逻辑过期</span></a></h4><blockquote><p>特点：高可用，性能优</p></blockquote><ul><li>缓存数据不真实删除，而是加上一个“逻辑过期时间”（在设置key的时候一并存入缓存）；</li><li>请求到达时若数据已逻辑过期，则： <ul><li>先返回旧值；</li><li>异步由后台线程更新缓存，避免并发冲击；</li></ul></li><li>常用于读多写少的场景（如热点文章详情页）。</li></ul><h4 id="_4-提前预热缓存" tabindex="-1"><a class="header-anchor" href="#_4-提前预热缓存"><span>4. 提前预热缓存</span></a></h4><ul><li>对于已知的热点数据（如大促商品、首页模块等），<strong>在系统启动或业务高峰前提前加载进缓存</strong>，避免过期带来的击穿。</li></ul><h2 id="_3-缓存雪崩" tabindex="-1"><a class="header-anchor" href="#_3-缓存雪崩"><span>3. 缓存雪崩</span></a></h2><blockquote><p><strong>缓存雪崩</strong>是指：<strong>大量缓存数据在同一时间集中过期或失效或者Redis服务宕机，导致大批请求绕过缓存直接访问数据库，引起数据库压力骤增甚至崩溃</strong>，从而造成整个系统不可用。</p></blockquote><h3 id="解决方案-2" tabindex="-1"><a class="header-anchor" href="#解决方案-2"><span>解决方案</span></a></h3><h4 id="_1-缓存过期时间加随机值" tabindex="-1"><a class="header-anchor" href="#_1-缓存过期时间加随机值"><span>1. 缓存过期时间加随机值</span></a></h4><ul><li>避免所有 key 过期时间一致；</li><li>示例：设置过期时间为 <code>600s + random(0~300s)</code>；</li><li>这样 key 的过期时间分散，避免集中过期。</li></ul><h4 id="_2-利用redis集群提高服务的可用性" tabindex="-1"><a class="header-anchor" href="#_2-利用redis集群提高服务的可用性"><span>2. 利用Redis集群提高服务的可用性</span></a></h4><p><strong>主从复制 + 哨兵模式（Sentinel）</strong></p><ul><li>Redis 主从架构，主节点写、从节点读；</li><li>配合哨兵（Sentinel）自动监控主节点健康；</li><li>主节点宕机时，哨兵自动完成故障转移（选举新的主节点）；</li><li>客户端自动感知主节点变化，保障服务不中断。</li></ul><p><strong>Redis Cluster 模式</strong></p><ul><li>数据分片到多个节点，每个节点负责部分 key；</li><li>自动管理主从结构和数据分布；</li><li>某个节点宕机时，其从节点可自动顶替，保证整体服务可用；</li><li>适用于大数据量 + 高并发场景。</li></ul><h4 id="_3-使用多级缓存架构" tabindex="-1"><a class="header-anchor" href="#_3-使用多级缓存架构"><span>3. 使用多级缓存架构</span></a></h4><ul><li>如：本地缓存（Guava、Caffeine） + 分布式缓存（Redis）；</li><li>缓解 Redis 失效时对数据库的直接冲击；</li><li>缺点是增加系统复杂性。</li></ul><h4 id="_4-请求限流与降级处理" tabindex="-1"><a class="header-anchor" href="#_4-请求限流与降级处理"><span>4. 请求限流与降级处理</span></a></h4><ul><li>设置接口限流策略，避免短时间请求爆发；</li><li>数据库压力过高时返回降级数据（如旧值、提示信息等）；</li><li>保证系统核心功能可用。</li></ul><h3 id="缓存三兄弟" tabindex="-1"><a class="header-anchor" href="#缓存三兄弟"><span>缓存三兄弟</span></a></h3><table><thead><tr><th>名称</th><th>触发条件</th><th>涉及 key</th><th>是否因攻击可控</th><th>解决重点</th></tr></thead><tbody><tr><td>缓存穿透</td><td>缓存和数据库都无该数据</td><td>大量不存在的 key</td><td>可被恶意触发</td><td>拦截非法请求</td></tr><tr><td>缓存击穿</td><td>热点 key 过期被高并发访问</td><td>单个热点 key</td><td>部分可控</td><td>限流 + 加锁 + 异步更新</td></tr><tr><td>缓存雪崩</td><td>大量 key 同时过期</td><td>大批有效 key</td><td>通常不可控</td><td>平滑过期 + 异步预热</td></tr></tbody></table><blockquote><p>打油诗：</p><p>穿透无中生有key，布隆过滤null隔离。</p><p>缓存击穿过期key，锁与非期解难题。</p><p>雪崩大量过期key，过期时间要随机。</p><p>面试必考三兄弟，可用限流来保底。</p></blockquote><h2 id="_4-缓存双写一致性" tabindex="-1"><a class="header-anchor" href="#_4-缓存双写一致性"><span>4. 缓存双写一致性</span></a></h2><h3 id="双写一致" tabindex="-1"><a class="header-anchor" href="#双写一致"><span>双写一致</span></a></h3><blockquote><p>当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p></blockquote><ul><li>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间</li><li>写操作：延迟双删（删除缓存→修改数据库→延时时间→删除缓存）</li></ul><h3 id="强一致性" tabindex="-1"><a class="header-anchor" href="#强一致性"><span>强一致性</span></a></h3><blockquote><p><strong>读多写少</strong></p><p>共享锁：读锁readLock，加锁之后，其他线程可以共享读操作</p><p>排他锁：独占锁writeLock，加锁之后，阻塞其他线程读写操作</p></blockquote><h3 id="允许延时一致" tabindex="-1"><a class="header-anchor" href="#允许延时一致"><span>允许延时一致</span></a></h3><ul><li>异步通知保证数据的最终一致性。基于MQ</li><li>基于Canal的异步通知，canal监听mysql的binlog（记录了所有DDL和DML语句），canal是基于mysql的主从同步来实现的</li></ul><h2 id="_5-redis持久化" tabindex="-1"><a class="header-anchor" href="#_5-redis持久化"><span>5. Redis持久化</span></a></h2><blockquote><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</p><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到。<code>save 900 1</code>，900秒内如果有1个key被修改，则触发RDB</p></blockquote><h3 id="rdb的执行原理" tabindex="-1"><a class="header-anchor" href="#rdb的执行原理"><span>RDB的执行原理</span></a></h3><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入RDB文件。</p><ul><li><p>fork采用的是copy-on-write技术：</p><blockquote><ul><li>当主进程执行读操作时，访问共享内存</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul></blockquote></li></ul><h3 id="aof" tabindex="-1"><a class="header-anchor" href="#aof"><span>AOF</span></a></h3><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看作是命令日志文件</p><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：<code>appendonly yes</code>，<code>appendfilename &quot;test.aof&quot;</code></p><p>AOF的命令记录的频率也可以通过redis.conf文件来配。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">appendfsync</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> always</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> #表示每执行一次命令，立即记录到AOF文件</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">appendfsync</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> everysec</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> #写命令执行完先放入AOF缓冲区，然后表示每隔一秒将缓冲区数据写到AOF文件，默认</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">appendfsync</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> no</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> #写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为是记录命令，AOF文件会比RDB文件大得多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同的效果。</p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值可以在redis.conf中配置。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">auto-aof-rewrite-percentage</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 100</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> #AOF文件比上次文件增长超过多少百分比则触发重写</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">auto-aof-rewrite-min-size</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 64mb</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> #AOF文件体积最小多大以上才触发重写</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="rdb和aof对比" tabindex="-1"><a class="header-anchor" href="#rdb和aof对比"><span>RDB和AOF对比</span></a></h3><table><thead><tr><th>特性</th><th>RDB（快照）</th><th>AOF（追加日志）</th></tr></thead><tbody><tr><td><strong>原理</strong></td><td>周期性保存内存数据快照到磁盘（<code>.rdb</code> 文件）</td><td>每次写操作追加到日志文件（<code>.aof</code> 文件）</td></tr><tr><td><strong>触发方式</strong></td><td>自动（定时/满足条件）或手动触发 <code>SAVE</code>/<code>BGSAVE</code></td><td>每次写操作都记录，后台异步写入</td></tr><tr><td><strong>数据恢复速度</strong></td><td>恢复快（加载 RDB 文件即可）</td><td>恢复较慢（需按日志重放命令）</td></tr><tr><td><strong>数据安全性（丢失）</strong></td><td>可能丢失最后一次快照后的数据</td><td>可配置为丢失毫秒级（appendfsync always）或秒级</td></tr><tr><td><strong>文件大小</strong></td><td>更小（结构化紧凑）</td><td>通常更大（命令日志）</td></tr><tr><td><strong>性能开销</strong></td><td>开销低，适合大数据量冷备</td><td>写操作频繁时开销大</td></tr><tr><td><strong>适用场景</strong></td><td>数据安全要求低、启动快</td><td>数据安全性要求高、日志追踪</td></tr></tbody></table><h2 id="_6-redis数据删除策略" tabindex="-1"><a class="header-anchor" href="#_6-redis数据删除策略"><span>6. Redis数据删除策略</span></a></h2><h3 id="惰性删除" tabindex="-1"><a class="header-anchor" href="#惰性删除"><span>惰性删除</span></a></h3><p>设置该key过期时间后，我们不管它，当需要该key时，我们再检查是否过期，如果过期，我们就删掉，反之返回该key</p><p>优点：对CPU友好，只会在使用时才检查</p><p>缺点：对内存不友好，如果一个Key过期，但长期未使用，那么该key就会一直存放在内存中，永远不会释放</p><h3 id="定期删除" tabindex="-1"><a class="header-anchor" href="#定期删除"><span>定期删除</span></a></h3><p>每隔一段时间，我们就对一些key进行检查，删除里面过期的key（从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key）</p><ul><li>SLOW模式：定时任务，执行频率默认是10hz，每次不能超过25ms，以通过修改配置文件的 hz 选项调整</li><li>FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</li></ul><blockquote><p>优点：可以通过限制删除操作执行的时长和频率来减少对删除操作对CPU的影响</p><p>缺点：难以确定删除操作执行的时长和频率。</p></blockquote><h3 id="redis的过期删除策略-惰性删除-定期删除两种策略配合使用" tabindex="-1"><a class="header-anchor" href="#redis的过期删除策略-惰性删除-定期删除两种策略配合使用"><span>Redis的过期删除策略：惰性删除+定期删除两种策略配合使用</span></a></h3><h2 id="_7-redis数据淘汰策略" tabindex="-1"><a class="header-anchor" href="#_7-redis数据淘汰策略"><span>7. Redis数据淘汰策略</span></a></h2><p>Redis 的<strong>数据淘汰策略</strong>（Eviction Policy）是在内存用满时，决定<strong>哪些数据要被删除</strong>来腾出空间的策略。只有在配置了 <code>maxmemory</code> 且数据超出限制时才会触发。</p><table><thead><tr><th>策略名</th><th>含义说明</th></tr></thead><tbody><tr><td><code>noeviction</code>（默认）</td><td>不删除数据，内存满后写操作报错（适合缓存+持久化共存时）</td></tr><tr><td><code>allkeys-lru</code></td><td>在所有键中，淘汰最近最少使用的键</td></tr><tr><td><code>volatile-lru</code></td><td>在设置了过期时间的键中，淘汰最近最少使用的键</td></tr><tr><td><code>allkeys-random</code></td><td>所有键中，随机淘汰一个键</td></tr><tr><td><code>volatile-random</code></td><td>在设置了过期时间的键中，随机淘汰一个键</td></tr><tr><td><code>volatile-ttl</code></td><td>在设置了过期时间的键中，优先淘汰快要过期的</td></tr><tr><td><code>allkeys-lfu</code></td><td>所有键中，淘汰使用频率最少的（Redis 4.0+）</td></tr><tr><td><code>volatile-lfu</code></td><td>在有过期时间的键中，淘汰使用频率最少的</td></tr></tbody></table><h2 id="_8-redis分布式锁" tabindex="-1"><a class="header-anchor" href="#_8-redis分布式锁"><span>8. Redis分布式锁</span></a></h2><p>Redis实现分布式锁主要利用Redis的setnx命令。setnx是SET if not exists（如果不存在，则SET）的简写</p><ul><li><p>获取锁：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#添加锁，NX是互斥的，EX是设置超时时间</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">SET</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> lock</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> value</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> NX</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> EX</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 10</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>释放锁：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#释放锁，删除即可</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">DEL</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> key</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="redis实现分布式锁如何合理的控制锁的有效时长" tabindex="-1"><a class="header-anchor" href="#redis实现分布式锁如何合理的控制锁的有效时长"><span>Redis实现分布式锁如何合理的控制锁的有效时长？</span></a></h3><blockquote><p>使用redisson实现分布式锁-执行流程。</p><ol><li>看门狗机制，给锁续期</li><li>抢不到锁的线程，会重试等待</li><li>加锁、设置过期时间等操作都是基于lua脚本完成，保证执行的完整性。</li></ol></blockquote><p><img src="`+t+`" alt="image-20250604161114820"></p><h3 id="redisson实现的分布式锁-可重入" tabindex="-1"><a class="header-anchor" href="#redisson实现的分布式锁-可重入"><span>Redisson实现的分布式锁-可重入</span></a></h3><ul><li>利用hash结构记录线程id和重入次数</li></ul><h3 id="redisson实现的分布式锁-主从一致性" tabindex="-1"><a class="header-anchor" href="#redisson实现的分布式锁-主从一致性"><span>Redisson实现的分布式锁-主从一致性</span></a></h3><ul><li>RedLock(红锁)：不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁（n/2 + 1），避免在一个redis实例上加锁。</li></ul><blockquote><p>不建议使用，如果非要保证强一致，可以采用zookeeper</p></blockquote><h2 id="_9-redis集群方案" tabindex="-1"><a class="header-anchor" href="#_9-redis集群方案"><span>9. Redis集群方案</span></a></h2><h3 id="主从复制" tabindex="-1"><a class="header-anchor" href="#主从复制"><span>主从复制</span></a></h3><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><h4 id="主从数据同步原理" tabindex="-1"><a class="header-anchor" href="#主从数据同步原理"><span>主从数据同步原理</span></a></h4><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td><strong>全量同步（Full Sync）</strong></td><td>第一次连接、重连时使用，拷贝主节点全量数据</td></tr><tr><td><strong>增量同步（Partial Resync）</strong></td><td>在网络中断后尽可能同步缺失的命令，而不是全量</td></tr></tbody></table><blockquote><p><strong>全量同步：</strong></p><ol><li>从节点请求主节点同步数据（replication id、offset）</li><li>主节点判断是否是第一次请i去，是第一次就与节点同步版本信息（replication id和offset）</li><li>主节点执行bgsave，生成rdb文件后，发送给从节点去执行</li><li>在rdb生成执行期间，主节点会以命令的方式记录到缓冲区（一个日志文件）</li><li>把生成之后的命令日志文件发送给从节点进行同步</li></ol><p><strong>增量同步：</strong></p><ol><li>从节点请求主节点同步数据，主节点判断不是第一次请求，获取从节点的offset值</li><li>主节点从命令日志中获取offset值之后的数据，发送给从节点进行同步</li></ol></blockquote><h3 id="哨兵模式" tabindex="-1"><a class="header-anchor" href="#哨兵模式"><span>哨兵模式</span></a></h3><blockquote><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</p><ul><li>监控：Sentinel会不断检查mater和slave</li><li>自动故障恢复：如果master故障，Sentinel会将一个slave提升至master。当故障实例恢复后也以新的master为主</li><li>通知：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端。</li></ul></blockquote><h4 id="服务状态监控" tabindex="-1"><a class="header-anchor" href="#服务状态监控"><span>服务状态监控</span></a></h4><ul><li>Sentinel基于心跳机制检测服务状态，每隔1秒向集群的每个实例发送ping命令 <ul><li>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。</li><li>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过sentinel实例数量的一半</li></ul></li></ul><h4 id="哨兵选主规则" tabindex="-1"><a class="header-anchor" href="#哨兵选主规则"><span>哨兵选主规则</span></a></h4><ul><li>首先判断主与从节点断开时间长短，如超过指定值就排除该从节点。</li><li>然后判断从节点的slave-priority值，越小优先级越高</li><li><strong>如果slave-priority一样，则判断slave节点的offset值，越大优先级越高。</strong></li><li>最后是判断slave节点的运行id大小，越小优先级越高</li></ul><h4 id="redis集群-哨兵模式-脑裂" tabindex="-1"><a class="header-anchor" href="#redis集群-哨兵模式-脑裂"><span>redis集群（哨兵模式）脑裂</span></a></h4><blockquote><p>同一个 Redis 集群中，<strong>原主节点还在对外提供服务</strong>，而哨兵却因网络原因误判其“宕机”，<strong>选出了新的主节点</strong>，导致同时存在两个主节点，造成<strong>数据不一致、写入丢失</strong>等问题。</p></blockquote><p><strong>解决方式：</strong></p><p>设置 <code>min-slaves-to-write</code> + <code>min-slaves-max-lag</code></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>min-slaves-to-write 1</span></span>
<span class="line"><span>min-slaves-max-lag 10</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>让主节点<strong>感知自己已孤立时自动拒绝写入</strong>，避免成为“孤岛主”。</li><li>如果主节点无法感知至少一个从节点 10 秒内正常响应，就拒绝写入；</li></ul><h3 id="分片集群" tabindex="-1"><a class="header-anchor" href="#分片集群"><span>分片集群</span></a></h3><h4 id="分片集群特征" tabindex="-1"><a class="header-anchor" href="#分片集群特征"><span>分片集群特征</span></a></h4><ul><li>集群有多个master，每个master保存不同数据</li><li>每个master都可以有多个slave节点</li><li>master之间通过ping监测彼此健康状态</li><li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</li></ul><h4 id="数据读写" tabindex="-1"><a class="header-anchor" href="#数据读写"><span>数据读写</span></a></h4><p>Redis分片集群引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p><ul><li>读写数据：根据key的有效部分计算哈希值，对16384取余（<strong>有效部分</strong>，如果key前面有大括号，大括号的内容就是有效部分，如果没有，则以key本身作为有效部分）余数为插槽，寻找插槽所在实例</li></ul><h2 id="redis是单线程的-但是为什么还那么快" tabindex="-1"><a class="header-anchor" href="#redis是单线程的-但是为什么还那么快"><span>Redis是单线程的，但是为什么还那么快</span></a></h2><h3 id="完全基于内存操作" tabindex="-1"><a class="header-anchor" href="#完全基于内存操作"><span>完全基于内存操作</span></a></h3><ul><li><p>所有数据都在内存中，避免了磁盘 I/O 的高延迟；</p></li><li><p>访问速度可达<strong>微秒级</strong>；</p></li></ul><h3 id="使用高性能的-i-o-多路复用机制" tabindex="-1"><a class="header-anchor" href="#使用高性能的-i-o-多路复用机制"><span>使用高性能的 I/O 多路复用机制</span></a></h3><ul><li>底层采用 <code>epoll</code>（Linux）+ 自定义事件循环，单线程也能处理<strong>高并发连接</strong>；</li><li>没有线程上下文切换的开销；</li></ul><blockquote><p>I/O 多路复用允许一个线程通过内核提供的接口，如 <code>select</code>、<code>poll</code>、<code>epoll</code>，同时监听多个 socket，当其中某个就绪后再处理，避免阻塞等待，极大提升了并发处理能力。目前的IO多路复用都是采用的epoll模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。Redis 就是基于 epoll 实现的高效事件驱动模型。</p></blockquote><table><thead><tr><th>模型</th><th>是否阻塞</th><th>性能</th><th>特点</th></tr></thead><tbody><tr><td><code>select</code></td><td>是</td><td>最差</td><td>最多支持 1024 个连接，效率低</td></tr><tr><td><code>poll</code></td><td>是</td><td>一般</td><td>支持更多连接，但每次都遍历全部 FD</td></tr><tr><td><code>epoll</code></td><td>否（事件驱动）</td><td>最佳（Linux）</td><td>支持大量连接，效率高，Redis/NGINX 用它</td></tr></tbody></table><h3 id="单线程避免了锁竞争" tabindex="-1"><a class="header-anchor" href="#单线程避免了锁竞争"><span>单线程避免了锁竞争</span></a></h3><ul><li>所有命令顺序执行，不用加锁，没有并发冲突；</li><li>线程安全天然保障 → 极简代码路径；</li></ul><h3 id="redis网络模型" tabindex="-1"><a class="header-anchor" href="#redis网络模型"><span>Redis网络模型</span></a></h3><ul><li><p>Redis通过IO多路复用来提高网络性能，并且支持各种不同的多路复用实现，并且将这些实现进行了封装，提供了统一的高性能事件库。</p></li><li><p>连接应答处理器</p></li><li><p>命令回复处理器，在Redis6.0之后，为了提升更好的性能，使用了多线程</p></li><li><p>命令请求处理器，在Redis6.0之后，将命令的转换使用了多线程，增加命令转换速度，在命令执行时依然是单线程。</p></li></ul>`,126)]))}const p=i(n,[["render",d]]),o=JSON.parse('{"path":"/studyNotes/ylz0ihmx/","title":"面试题-redis","lang":"zh-CN","frontmatter":{"title":"面试题-redis","createTime":"2025/07/03 02:39:45","permalink":"/studyNotes/ylz0ihmx/"},"readingTime":{"minutes":15.44,"words":4633},"git":{"updatedTime":1749436129000,"contributors":[{"name":"Lang","username":"Lang","email":"914551901@qq.com","commits":3,"avatar":"https://avatars.githubusercontent.com/Lang?v=4","url":"https://github.com/Lang"}]},"filePathRelative":"notes/学习笔记/八股文/面试题-redis.md","headers":[]}');export{p as comp,o as data};
