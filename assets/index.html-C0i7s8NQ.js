import{_ as i,c as l,a as e,o as n}from"./app-dsZ4C4U9.js";const s="/assets/v2-1d38c56fcb3eff75f9cbc5d16b4b457e_r-cU52qUYH.jpg",h={};function r(t,a){return n(),l("div",null,a[0]||(a[0]=[e('<ol><li>单一职责原则</li><li>接口隔离原则</li><li>依赖倒转原则</li><li>里氏替换原则</li><li>开闭原则OCP</li><li>迪米特法则</li><li>合成复用原则</li></ol><h1 id="单一职责原则" tabindex="-1"><a class="header-anchor" href="#单一职责原则"><span>单一职责原则</span></a></h1><h2 id="基本介绍" tabindex="-1"><a class="header-anchor" href="#基本介绍"><span>基本介绍</span></a></h2><ul><li>对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。 当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1，A2。</li></ul><h2 id="注意事项和细节" tabindex="-1"><a class="header-anchor" href="#注意事项和细节"><span>注意事项和细节</span></a></h2><ol><li>降低类的复杂度，一个类只负责一项职责。</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违 反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li></ol><h1 id="接口隔离原则" tabindex="-1"><a class="header-anchor" href="#接口隔离原则"><span>接口隔离原则</span></a></h1><h2 id="基本介绍-1" tabindex="-1"><a class="header-anchor" href="#基本介绍-1"><span>基本介绍</span></a></h2><ul><li>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖 应该建立在最小的接口上</li></ul><p><img src="https://raw.githubusercontent.com/lrffun/ImageStorage/main/img/image-20240416143007095.png" alt="image-20240416143007095"></p><h2 id="改进方法" tabindex="-1"><a class="header-anchor" href="#改进方法"><span>改进方法</span></a></h2><ol><li>类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口 Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不 需要的方法</li><li>将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立 依赖关系。也就是采用接口隔离原则</li><li>接口Interface1中出现的方法，根据实际情况拆分为三个接口</li></ol><p><img src="https://raw.githubusercontent.com/lrffun/ImageStorage/main/img/image-20240416143046509.png" alt="image-20240416143046509"></p><h1 id="依赖倒转原则" tabindex="-1"><a class="header-anchor" href="#依赖倒转原则"><span>依赖倒转原则</span></a></h1><h2 id="基本介绍-2" tabindex="-1"><a class="header-anchor" href="#基本介绍-2"><span>基本介绍</span></a></h2><ol><li>高层模块不应该依赖底层模块，二者都应该依赖其抽象</li><li><code>抽象不应该依赖细节，细节应该依赖抽象。</code></li><li>依赖倒转的中心思想是面向接口编程</li><li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象值指的是接口或抽象类，细节就是具体的实现类。</li><li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</li></ol><h2 id="依赖关系传递的三种方式" tabindex="-1"><a class="header-anchor" href="#依赖关系传递的三种方式"><span>依赖关系传递的三种方式</span></a></h2><ol><li>接口传递</li><li>构造方法传递</li><li>setter方式传递</li></ol><h2 id="依赖倒转原则的注意事项" tabindex="-1"><a class="header-anchor" href="#依赖倒转原则的注意事项"><span>依赖倒转原则的注意事项</span></a></h2><ol><li>底层模块尽量都要有抽象类或接口，程序稳定性更好</li><li>变量的声明类型尽量使抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化。</li><li>继承时遵循里氏替换原则。</li></ol><h1 id="里氏替换原则" tabindex="-1"><a class="header-anchor" href="#里氏替换原则"><span>里氏替换原则</span></a></h1><h2 id="基本介绍-3" tabindex="-1"><a class="header-anchor" href="#基本介绍-3"><span>基本介绍</span></a></h2><ul><li>继承再给程序设计带来遍历的同时，也带来了弊端</li><li>基本原则：所有应用基类的地方必须能透明地使用其子类的对象。</li><li>在使用继承的时候，遵循里氏替换原则，在子类中尽量不要重写父类的方法</li><li>适当情况下，可以通过聚合、组合、依赖来解决</li></ul><h1 id="开闭原则" tabindex="-1"><a class="header-anchor" href="#开闭原则"><span>开闭原则</span></a></h1><h2 id="基本介绍-4" tabindex="-1"><a class="header-anchor" href="#基本介绍-4"><span>基本介绍</span></a></h2><ul><li>一个软件实体，如类、模块和函数应该对扩展开放（提供方），对修改关闭（对使用方）。用抽象构建框架，用实现扩展细节。</li><li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li><li>编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则。</li></ul><h1 id="迪米特法则" tabindex="-1"><a class="header-anchor" href="#迪米特法则"><span>迪米特法则</span></a></h1><h2 id="基本介绍-5" tabindex="-1"><a class="header-anchor" href="#基本介绍-5"><span>基本介绍</span></a></h2><ul><li><p>一个对象应该对其它对象保持最少的了解</p></li><li><p>类与类关系越密切，耦合度越大</p></li><li><p>迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息</p></li><li><p>迪米特法则还有个更简单的定义：只与直接的朋友通信</p></li></ul><h1 id="合成复用原则" tabindex="-1"><a class="header-anchor" href="#合成复用原则"><span>合成复用原则</span></a></h1><h2 id="基本介绍-6" tabindex="-1"><a class="header-anchor" href="#基本介绍-6"><span>基本介绍</span></a></h2><ul><li>原则是尽量使用合成/聚合的方式，而不是使用继承。</li></ul><h1 id="设计原则核心思想" tabindex="-1"><a class="header-anchor" href="#设计原则核心思想"><span>设计原则核心思想</span></a></h1><ul><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起</li><li>针对接口编程，而不是针对实现编程。</li><li>为了交互对象之间的松耦合设计而努力。</li></ul><h1 id="设计模式类型" tabindex="-1"><a class="header-anchor" href="#设计模式类型"><span>设计模式类型</span></a></h1><ul><li>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式</li><li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式</li><li>行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式</li></ul><p><img src="'+s+'" alt="v2-1d38c56fcb3eff75f9cbc5d16b4b457e_r"></p>',37)]))}const d=i(h,[["render",r]]),p=JSON.parse('{"path":"/studyNotes/uwdw6vox/","title":"设计模式七大原则","lang":"zh-CN","frontmatter":{"title":"设计模式七大原则","createTime":"2025/04/24 18:35:31","permalink":"/studyNotes/uwdw6vox/"},"readingTime":{"minutes":4.69,"words":1406},"git":{"updatedTime":1745747081000,"contributors":[{"name":"Lang","username":"Lang","email":"914551901@qq.com","commits":3,"avatar":"https://avatars.githubusercontent.com/Lang?v=4","url":"https://github.com/Lang"}]},"filePathRelative":"notes/学习笔记/设计模式/设计模式七大原则.md","headers":[]}');export{d as comp,p as data};
