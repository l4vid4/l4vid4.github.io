import{_ as a,c as n,a as e,o as i}from"./app-dsZ4C4U9.js";const l="/assets/Pasted%20image%2020221206112205-BjDmFEfD.png",p={};function d(c,s){return i(),n("div",null,s[0]||(s[0]=[e(`<p>帮助快速上手汇编语言编程，虽然只限于编程</p><h1 id="vscode配置调试环境" tabindex="-1"><a class="header-anchor" href="#vscode配置调试环境"><span>VScode配置调试环境</span></a></h1><ol><li>安装插件TASM/MASM</li><li>右键扩展设置，选择Assembler：MASM</li><li>右键调试即可开始调试了！</li></ol><h1 id="debug-exe" tabindex="-1"><a class="header-anchor" href="#debug-exe"><span>Debug.exe</span></a></h1><blockquote><p>R命令：查看、改变CPU寄存器的内容 D命令：查看内存中的内容 T命令：执行一条机器指令 G命令：从停顿的地方运行到底</p></blockquote><h1 id="第一段代码-hello-world" tabindex="-1"><a class="header-anchor" href="#第一段代码-hello-world"><span>第一段代码：Hello World</span></a></h1><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>DSEG SEGMENT</span></span>
<span class="line"><span>        MESS DB &#39;Hello, World!&#39;,0DH,0AH,24H</span></span>
<span class="line"><span>DSEG ENDS</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SSEG SEGMENT PARA STACK</span></span>
<span class="line"><span>             DW 256 DUP(?)</span></span>
<span class="line"><span>SSEG ENDS</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CSEG SEGMENT</span></span>
<span class="line"><span>              ASSUME CS:CSEG, DS:DSEG</span></span>
<span class="line"><span>        BEGIN:MOV    AX,DSEG</span></span>
<span class="line"><span>              MOV    DS,AX</span></span>
<span class="line"><span>              MOV    DX,OFFSET MESS</span></span>
<span class="line"><span>              </span></span>
<span class="line"><span>              MOV    AH,9</span></span>
<span class="line"><span>              INT    21H</span></span>
<span class="line"><span>              </span></span>
<span class="line"><span>              MOV    AH,4CH</span></span>
<span class="line"><span>              INT    21H</span></span>
<span class="line"><span>CSEG ENDS</span></span>
<span class="line"><span>END BEGIN</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="基础指令" tabindex="-1"><a class="header-anchor" href="#基础指令"><span>基础指令</span></a></h1><p>用以下指令可以写一个基础的程序：</p><ol><li>段定义+Assume</li></ol><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>XXX SEGMENT(XXX:DATA/STACK/CODE)</span></span>
<span class="line"><span>XXX ENDS</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>ASSUME CS:CSEG, DS:DSEG, SS:SSEG</span></span>
<span class="line"><span>MOV AX,DSEG</span></span>
<span class="line"><span>MOV DS,AX</span></span>
<span class="line"><span>MOV AX,SSEG</span></span>
<span class="line"><span>MOV SS,AX</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>数据定义</li></ol><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>(ORG 1000)</span></span>
<span class="line"><span>(NAME) DB ?/...</span></span>
<span class="line"><span>(NAME) DB N DUP(?/...)</span></span>
<span class="line"><span>db:12H/dw:1234H</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>MOV</li></ol><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span> MOV AX,Y</span></span>
<span class="line"><span> MOV Y,AX</span></span>
<span class="line"><span> MOV AX,BX</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>+-</li></ol><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>ADD AX,X;AX+=X</span></span>
<span class="line"><span>SUB AX,X;AX-=X</span></span>
<span class="line"><span>INC AX;AX++</span></span>
<span class="line"><span>DEC AX;AX--</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NEG AX ;取负</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li>程序的终止</li></ol><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>MOV AH,4CH</span></span>
<span class="line"><span>INT 21H</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>稍后会讲的进阶指令：</p><ol><li>Label和JUMP：跳转</li><li>分支和循环</li><li>堆栈的使用</li><li>&lt;函数&gt;：PROC和MACRO</li><li>INT 21H指令：输入/输出</li></ol><h1 id="寄存器的使用" tabindex="-1"><a class="header-anchor" href="#寄存器的使用"><span>寄存器的使用</span></a></h1><p>在汇编语言中，我们不能对内存中的数据进行直接操作，如果要操作，需要把数据先<code>MOV</code>到寄存器中再进行处理。 为了写代码的过程更顺滑，最好先简单了解一下这些寄存器的使用，当然，你也可以只了解通用寄存器的使用，别的等用到了再去查询。 我会尽可能简单地表述。</p><p>8086 CPU 中有14个16位寄存器 。16位的存储可以用16进制表示，BeLike：<code>123AH</code>（H表示16进制)在查看内存情况的时候，由于数据从高位到低位存储，BeLike：<code>3A 12</code></p><p><img src="https://img-blog.csdnimg.cn/20200512110737331.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h3 id="通用寄存器-ax-bx-cx-dx" tabindex="-1"><a class="header-anchor" href="#通用寄存器-ax-bx-cx-dx"><span>通用寄存器：AX，BX，CX，DX</span></a></h3><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>DSEG ...</span></span>
<span class="line"><span>X DB 12H</span></span>
<span class="line"><span>Y DB ?</span></span>
<span class="line"><span>....</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CSEG...</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>MOV AH,X</span></span>
<span class="line"><span>MOV Y,AH ;Y--12H</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以拆分为两个寄存器使用（AH和AL），不过各自有各自的独特作用，用到再提，这和它们的名字是关联的</p><p>说到底为什么&lt;通用&gt;寄存器会有&lt;独特的作用&gt;？ 这是因为<mark>一些内置的指令依靠<strong>固定</strong>的寄存器传递参数</mark>，所以这些寄存器也有了独特的作用</p><p>一般来说随便用就可以，反正里面的东西不久存，只是用来做<mark>中转</mark></p><h5 id="ax-accumlator-累加器" tabindex="-1"><a class="header-anchor" href="#ax-accumlator-累加器"><span>AX：Accumlator 累加器</span></a></h5><p>特殊功能和MUL/DIV有关，后面再说</p><h5 id="bx-base-基地址寄存器" tabindex="-1"><a class="header-anchor" href="#bx-base-基地址寄存器"><span>BX：Base 基地址寄存器</span></a></h5><p>可以存储地址并访问 说到地址，就得提一下汇编语言里地址的表示方法 在汇编语言里，内存中的地址BeLike：<code>204B:1001</code> （以16进制表示） <code>204B</code>是<strong>段地址</strong>，<code>1001</code>是<strong>偏移地址</strong>，各需要一个Word进行存储 有两个指令对应的获取内存单元的这两种地址 <code>SEG</code>可以获取<strong>段地址</strong>（这个段就是指我们程序对应的段Segment），<code>OFFSET</code>可以获取<strong>偏移地址</strong> 使用这两个词只需要在MOV时加在变量前即可，比如<code>MOV BX offset X</code> 在“通过地址找内容”这件事方面，一般用BX存储偏移地址 比如：</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>	X DW 1234H</span></span>
<span class="line"><span>	Y DW ?</span></span>
<span class="line"><span>	...</span></span>
<span class="line"><span>	MOV BX, OFFSET X;BX中存储了X的偏移地址</span></span>
<span class="line"><span>	MOV Y, [BX];BX存储的偏移地址对应的内容被存放到y</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般来说，<code>[BX]</code>就是指 <code>DS:[BX]</code>，默认段地址为数据段，当然你也可以指定为CS和SS</p><h5 id="cx-count-计数器" tabindex="-1"><a class="header-anchor" href="#cx-count-计数器"><span>CX：Count 计数器</span></a></h5><p>和循环指令<code>LOOP</code>有关</p><p>LOOP指令类似于C语言中的For循环，<code>loop NAME</code>近似于<code>for(cx;;cx--)</code> 关于LOOP的用法，具体到程序结构再说好了~。</p><h5 id="dx-data-数据寄存器" tabindex="-1"><a class="header-anchor" href="#dx-data-数据寄存器"><span>DX：Data 数据寄存器</span></a></h5><p>特殊功能和MUL/DIV有关，后面再说 也有与输入输出的暂存有关的功能（9.10号指令）</p><h3 id="指针变址寄存器-sp-bp-si-di" tabindex="-1"><a class="header-anchor" href="#指针变址寄存器-sp-bp-si-di"><span>指针变址寄存器：SP，BP，SI，DI</span></a></h3><p>都倾向于用来存地址</p><h5 id="sp-stack-pointer" tabindex="-1"><a class="header-anchor" href="#sp-stack-pointer"><span>SP：Stack Pointer</span></a></h5><p>和堆栈段的使用有关，定义堆栈段要记得手动把SP放在栈顶</p><h5 id="bp-base-pointer" tabindex="-1"><a class="header-anchor" href="#bp-base-pointer"><span>BP：Base Pointer</span></a></h5><p>和BX有类似的用法，只是一般更倾向于用在堆栈的数据里，<code>[BP]</code>默认为<code>SS:[BP]</code></p><h5 id="si-source-index" tabindex="-1"><a class="header-anchor" href="#si-source-index"><span>SI：Source Index</span></a></h5><h5 id="di-destination-index" tabindex="-1"><a class="header-anchor" href="#di-destination-index"><span>DI：Destination Index</span></a></h5><p>和BX有类似的用法，<code>[SI]</code>默认为<code>DS:[SI]</code> 如果要转移数据，倾向于用SI存原地址，DI存新地址</p><h3 id="段寄存器-cs-ds-ss-es-ip" tabindex="-1"><a class="header-anchor" href="#段寄存器-cs-ds-ss-es-ip"><span>段寄存器：CS，DS，SS，ES，IP</span></a></h3><p>段的存在方便我们以<mark>段地址+偏移地址</mark>的方式定位内存单元 刚刚在例子中看到，一般的程序我们定义三个段，Data、Stack和Code，它们的作用和名字是一致的</p><p>这些寄存器都和程序段还有程序的运行有关。 在程序启动的时候，操作系统会把IP（Instruction Pointer）指向程序的第一句开始运行，之后IP会一直指向每次要运行的下一条指令（显然我们可以用IP玩一些花活，但是对于简单的程序，我们没有必要操作IP）</p><p>在代码段的开始，我们就用Assume语句声明CS、DS、SS的地址 和CS不同，DS和SS寄存器的值需要我们手动指定，而与SS寄存器绑定的SP指针也需要我们手动设置（SS:SP指向的就是栈顶元素）</p><p>ES是Extra Segment，程序有附加段落的时候才用，用法和DS SS差不多</p><h3 id="标志寄存器-flag" tabindex="-1"><a class="header-anchor" href="#标志寄存器-flag"><span>标志寄存器 FLAG</span></a></h3><p>只是写代码的话不用管它 16位分开使用，有各自不同的意思，结果会以下面的形式呈现在-R中</p><p><img src="https://img-blog.csdnimg.cn/20200512122803832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt=""></p><h1 id="阶段练习" tabindex="-1"><a class="header-anchor" href="#阶段练习"><span>阶段练习</span></a></h1><p>有以上的知识已经能写很多代码。</p><h4 id="练习a-x-y" tabindex="-1"><a class="header-anchor" href="#练习a-x-y"><span>练习a: x+y</span></a></h4><blockquote><ol><li>在数据段（data segment）中定义3个word，其中x=1234H，y=2345H, z=?</li><li>将x+y的结果保存在z中</li></ol></blockquote><h1 id="进阶指令" tabindex="-1"><a class="header-anchor" href="#进阶指令"><span>进阶指令</span></a></h1><p>这里开始会有一点复杂，建议一边写一边看</p><h3 id="_1-label和jump-跳转" tabindex="-1"><a class="header-anchor" href="#_1-label和jump-跳转"><span>1. Label和Jump：跳转</span></a></h3><p>一段代码可以拥有label，Jump NAME 即可跳转至label位置 比如</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>MAIN：MOV X,AX</span></span>
<span class="line"><span>JUMP DONE</span></span>
<span class="line"><span>MOV AX,Y</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>DONE:</span></span>
<span class="line"><span>	MOV AH, 4CH</span></span>
<span class="line"><span>	INT 21</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段程序中，<code>MOV AX,Y</code>就会直接被跳过</p><h3 id="_2-分支和循环" tabindex="-1"><a class="header-anchor" href="#_2-分支和循环"><span>2. 分支和循环</span></a></h3><h4 id="分支-cmp-jge" tabindex="-1"><a class="header-anchor" href="#分支-cmp-jge"><span>分支 CMP-JGE/...</span></a></h4><p><img src="`+l+`" alt=""></p><p>BeLike:(求abs(AX)保存在AX中)</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>MAIN:</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>CMP AX,0</span></span>
<span class="line"><span>JGE DONE; Jump if Greater or Equal</span></span>
<span class="line"><span>NEG AX;取相反数</span></span>
<span class="line"><span>DONE:</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>END MAIN</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="练习b-求最大值" tabindex="-1"><a class="header-anchor" href="#练习b-求最大值"><span>练习b: 求最大值</span></a></h5><blockquote><ol><li>在数据段（data segment）中定义4个word，其中x=1234H，y=2345H, z=-1234H，w=?</li><li>求max(x,y,z)储存于w</li></ol></blockquote><h4 id="循环-loop" tabindex="-1"><a class="header-anchor" href="#循环-loop"><span>循环 LOOP</span></a></h4><p>一种简单的循环，类似于<code>for(cx;;cx--)</code>。（事实上，你可以用JUMP和分支结构来实现循环）</p><p>LOOP NM过程中： 0. CMP CX,0 1. 如果CX&gt;0，继续执行以下语句，否则跳出 2. DEC CX(CX&gt;0) 3. JUMP NM</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>MOV CX,6</span></span>
<span class="line"><span>NM: ...</span></span>
<span class="line"><span>LOOP NM;这样写一共执行CX次（声明NM时执行1次，LOOP中执行CX-1次）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="练习c-数组初始化" tabindex="-1"><a class="header-anchor" href="#练习c-数组初始化"><span>练习c: 数组初始化</span></a></h5><blockquote><p>在数据段（data segment）中分配100字节，并为每个字节依次赋值0-99。</p></blockquote><h3 id="_3-堆栈的使用" tabindex="-1"><a class="header-anchor" href="#_3-堆栈的使用"><span>3. 堆栈的使用</span></a></h3><h4 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化"><span>初始化</span></a></h4><p>两个好用的方法</p><h5 id="比较直观的-堆栈段中做定义" tabindex="-1"><a class="header-anchor" href="#比较直观的-堆栈段中做定义"><span>比较直观的（堆栈段中做定义）</span></a></h5><ol><li>在堆栈段划分位置，保存栈顶位置</li><li>在程序段开始的时候把堆栈段的位置告诉堆栈寄存器SS，把栈顶的位置告诉指针寄存器SP</li></ol><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SSEG SEGMENT</span></span>
<span class="line"><span>      STACK DW  128 dup(?)</span></span>
<span class="line"><span>      TOP   DW LENGTH STACK ;划定范围</span></span>
<span class="line"><span>SSEG ENDS</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CSEG SEGMENT</span></span>
<span class="line"><span>           ASSUME CS:CSEG,DS:DSEG,SS:SSEG</span></span>
<span class="line"><span>      MAIN:</span></span>
<span class="line"><span>           MOV    AX,DSEG</span></span>
<span class="line"><span>           MOV    DS,AX</span></span>
<span class="line"><span>           MOV    AX,SSEG  </span></span>
<span class="line"><span>           MOV    SS,AX</span></span>
<span class="line"><span>           MOV    AX,TOP</span></span>
<span class="line"><span>           MOV    SP,AX                        ;栈顶地址载入</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="稍微没那么直观的-程序段中划空间" tabindex="-1"><a class="header-anchor" href="#稍微没那么直观的-程序段中划空间"><span>稍微没那么直观的（程序段中划空间）</span></a></h5><p>直接给SP赋值</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SSEG SEGMENT</span></span>
<span class="line"><span>SSEG ENDS</span></span>
<span class="line"><span>;ss:0000-ss:1000</span></span>
<span class="line"><span>CSEG SEGMENT</span></span>
<span class="line"><span>            ASSUME CS:CSEG, DS:DSEG,SS:SSEG</span></span>
<span class="line"><span>      BEGIN:MOV    AX,DSEG</span></span>
<span class="line"><span>            MOV    DS,AX</span></span>
<span class="line"><span>            MOV    AX,SSEG</span></span>
<span class="line"><span>            MOV    SS,AX</span></span>
<span class="line"><span>            MOV    SP,1000H                      ;手动规定了1000H的空置空间(OFFSET 0H-1000H)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="push和pop" tabindex="-1"><a class="header-anchor" href="#push和pop"><span>PUSH和POP</span></a></h4><p>注意：<mark>只能操作寄存器</mark>，不能直接操作内存单元 <code>PUSH AX</code>：将AX的值入栈（如果AX两个字节，就会入栈两个字节，SP也相应-2） <code>POP AX</code>：出栈，内容保存在AX（如果AX两个字节，就会入栈两个字节，SP也相应+2）</p><h4 id="用sp和bp操作堆栈" tabindex="-1"><a class="header-anchor" href="#用sp和bp操作堆栈"><span>用SP和BP操作堆栈</span></a></h4><p>在主程序只是暂存数据用的话，一般<mark>不用</mark>操作指针 但是，由于PROC需要使用到堆栈段，所以这是操作指针就是必要的，接下来在PROC中解释</p><h3 id="_4-函数-proc和macro" tabindex="-1"><a class="header-anchor" href="#_4-函数-proc和macro"><span>4. &lt;函数&gt;：PROC和MACRO</span></a></h3><h4 id="proc-call-子程序结构" tabindex="-1"><a class="header-anchor" href="#proc-call-子程序结构"><span>PROC&amp;CALL（子程序结构）</span></a></h4><h5 id="定义-proc-ret-endp" tabindex="-1"><a class="header-anchor" href="#定义-proc-ret-endp"><span>定义 PROC-RET-ENDP</span></a></h5><p>(Near 属性是默认值)</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>MAIN:</span></span>
<span class="line"><span>CALL NM</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NM PROC</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>RET</span></span>
<span class="line"><span>NM ENDP</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>END MAIN</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完整的表达式： 调用：<code>CALL FAR/NEAR PTR NM</code> 定义：<code>NM PROC FAR/NEAR</code></p><h5 id="子程序属性和调用" tabindex="-1"><a class="header-anchor" href="#子程序属性和调用"><span>子程序属性和调用</span></a></h5><h6 id="段内调用" tabindex="-1"><a class="header-anchor" href="#段内调用"><span>段内调用</span></a></h6><p>只需要Main（主Label调用）的话空置即可（默认Near）</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>A:...</span></span>
<span class="line"><span>	CALL B;调用B</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	PROC B:...;默认为near属性子程序</span></span>
<span class="line"><span>	RET</span></span>
<span class="line"><span>	B ENDP</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>END A</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6 id="段间调用" tabindex="-1"><a class="header-anchor" href="#段间调用"><span>段间调用</span></a></h6><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>PROC A:CALL FAR PTR B</span></span>
<span class="line"><span>RET</span></span>
<span class="line"><span>ENDP</span></span>
<span class="line"><span></span></span>
<span class="line"><span>PROC B FAR:...;写明属性</span></span>
<span class="line"><span>RET ENDP</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="小心堆栈" tabindex="-1"><a class="header-anchor" href="#小心堆栈"><span>小心堆栈！</span></a></h5><p>PROC的本质是：入栈程序出口指针，RET时从回到出口指针的位置 所以：</p><ol><li>第一个出栈元素会是一个偏移地址</li><li>如果最后SP的指针位置不对，就无法正确RET</li></ol><p>简单的方法：<mark>用寄存器BP保护SP</mark>，使用BP进行数据的读取</p><h6 id="例子a-1-x-y子程序化" tabindex="-1"><a class="header-anchor" href="#例子a-1-x-y子程序化"><span>例子a(1): x+y子程序化</span></a></h6><blockquote><p>...</p><ol><li>在堆栈段push任意两个长度为1word的数据</li><li>使用子程序，将这两个数据的和存储于AX ...</li></ol></blockquote><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SUM PROC ;取两个栈顶元素求和储存到AX中</span></span>
<span class="line"><span>         MOV    BP,SP</span></span>
<span class="line"><span>         MOV    AX,[BP+2]</span></span>
<span class="line"><span>         ADD    AX,[BP+4]</span></span>
<span class="line"><span>         RET</span></span>
<span class="line"><span>SUM ENDP</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6 id="练习b-1-求最大值-子程序化" tabindex="-1"><a class="header-anchor" href="#练习b-1-求最大值-子程序化"><span>练习b(1) 求最大值 子程序化</span></a></h6><blockquote><ol><li>在数据段（data segment）中定义4个word，其中x=1234H，y=2345H, z=-1234H，w=?</li><li>在堆栈段push x,y,z</li><li>求max(x,y,z)储存于w</li></ol></blockquote><h4 id="macro-宏定义" tabindex="-1"><a class="header-anchor" href="#macro-宏定义"><span>*Macro（宏定义）</span></a></h4><p>PROC的使用有调用开销（程序的中断 跳转 继续），而MACRO没有 MACRO相当于写代码的人把重复写代码的过程交给了汇编器，相比子程序来说，是通过多占程序的内存来提高运行速度（对机器来说，每调用一次Macro，就是把这段指令重复了一次）</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>NM MACRO R1,R2...(参数)</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>END M</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NM MACRO AX,BX...(寄存器取值)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-int-21h指令-输入-输出" tabindex="-1"><a class="header-anchor" href="#_5-int-21h指令-输入-输出"><span>5. INT 21H指令：输入/输出</span></a></h3><p>其实查书就可以了</p><p>到这里汇编语言编程的&lt;大局&gt;已经描述完全</p><p>关于一些语句的细节可以通过搜索引擎和汇编相关的任何书籍进行确认~</p><h4 id="键盘输入" tabindex="-1"><a class="header-anchor" href="#键盘输入"><span>键盘输入</span></a></h4><h5 id="_1号指令-单个字符输入" tabindex="-1"><a class="header-anchor" href="#_1号指令-单个字符输入"><span>1号指令：单个字符输入</span></a></h5><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>MOV AH,1</span></span>
<span class="line"><span>INT 21H</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>(内容会保存在AL)</p><h5 id="_10号指令-从键盘输入字符串" tabindex="-1"><a class="header-anchor" href="#_10号指令-从键盘输入字符串"><span>10号指令：从键盘输入字符串</span></a></h5><p>内存里需要划分三个部分： 1.一个字节存放最大长度（你写，溢出会被裁掉） 2.一个字节存放实际长度（指令运行完CPU会写） 3.一些字节用来存字符串</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>DATA SEGMENT</span></span>
<span class="line"><span>    MAXLENGTH    DB 100           ;一个字节，用它存最大的长度</span></span>
<span class="line"><span>    ACTUALLENGTH DB ?             ;一个字节，用它存实际的长度，在指令执行后会被填写</span></span>
<span class="line"><span>    STRING       DB 100 DUP(?)    ;用来存字符串</span></span>
<span class="line"><span>DATA ENDS</span></span>
<span class="line"><span></span></span>
<span class="line"><span>STACK SEGMENT</span></span>
<span class="line"><span>STACK ENDS</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CODE SEGMENT</span></span>
<span class="line"><span>         ASSUME DS:DATA,SS:STACK,CS:CODE</span></span>
<span class="line"><span>    MAIN:</span></span>
<span class="line"><span>         MOV    AX,DATA</span></span>
<span class="line"><span>         MOV    DS,AX</span></span>
<span class="line"><span>         MOV    DX,OFFSET MAXLENGTH         ;把需要用到的内存块（三个部分）的地址存入DX</span></span>
<span class="line"><span></span></span>
<span class="line"><span>         MOV    AH,10</span></span>
<span class="line"><span>         INT    21H</span></span>
<span class="line"><span></span></span>
<span class="line"><span>         MOV    AH,4CH</span></span>
<span class="line"><span>         INT    21H</span></span>
<span class="line"><span>CODE ENDS</span></span>
<span class="line"><span>END MAIN</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="显示器输出" tabindex="-1"><a class="header-anchor" href="#显示器输出"><span>显示器输出</span></a></h4><h5 id="_2号调用-单个字符输出" tabindex="-1"><a class="header-anchor" href="#_2号调用-单个字符输出"><span>2号调用：单个字符输出</span></a></h5><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>MOV DL,&#39;A&#39;</span></span>
<span class="line"><span>MOV AH,2</span></span>
<span class="line"><span>INT 21H</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_9号调用-字符串输出" tabindex="-1"><a class="header-anchor" href="#_9号调用-字符串输出"><span>9号调用：字符串输出</span></a></h5><p>你的字符串必须要以&#39;$&#39;结尾！不然输出不会结束！（类似于&#39;\\0&#39;，&#39;$&#39;是一种字符串的终止符） 程序会将DS:DX地址开始输出字符到&#39;$&#39;结尾</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>MOV DX,OFFSET STRING</span></span>
<span class="line"><span>MOV AH,9</span></span>
<span class="line"><span>INT 21H</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="综合练习" tabindex="-1"><a class="header-anchor" href="#综合练习"><span>综合练习</span></a></h3><h4 id="练习d-大小写转换-输入输出" tabindex="-1"><a class="header-anchor" href="#练习d-大小写转换-输入输出"><span>练习d. 大小写转换+输入输出</span></a></h4><blockquote><p>（分支/循环/子程序+输入输出） 用户输入一个单词，程序将所有大写转换为小写并输出到显示器 (注：&#39;a&#39;=&#39;A&#39;+20H)</p></blockquote>`,139)]))}const h=a(p,[["render",d]]),t=JSON.parse('{"path":"/studyNotes/8vc1i9sg/","title":"汇编语言","lang":"zh-CN","frontmatter":{"title":"汇编语言","createTime":"2025/04/24 18:35:24","permalink":"/studyNotes/8vc1i9sg/"},"readingTime":{"minutes":10.27,"words":3081},"git":{"updatedTime":1746760412000,"contributors":[{"name":"Lang","username":"Lang","email":"914551901@qq.com","commits":4,"avatar":"https://avatars.githubusercontent.com/Lang?v=4","url":"https://github.com/Lang"}]},"filePathRelative":"notes/学习笔记/汇编语言/汇编语言.md","headers":[]}');export{h as comp,t as data};
