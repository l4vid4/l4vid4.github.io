import{_ as a}from"./59a1cd98b61671b569e9817708de262a-5KDefroA.js";import{_ as s,c as r,a as e,o as d}from"./app-dsZ4C4U9.js";const i="/assets/af1ea7d9965ada42d97f8d10c5e879b9-BCS0ogSN.png",n="/assets/73496942ccf51c9890d23ba12f5d4932-eUnqoWCi.png",o={};function l(h,t){return d(),r("div",null,t[0]||(t[0]=[e('<p>[TOC]</p><h2 id="_1-hashmap底层源码" tabindex="-1"><a class="header-anchor" href="#_1-hashmap底层源码"><span>1. HashMap底层源码</span></a></h2><blockquote><p><a href="https://blog.csdn.net/v123411739/article/details/78996181" target="_blank" rel="noopener noreferrer">HashMap详解</a></p></blockquote><h3 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h3><p><strong>数组（Node[] table）</strong>：HashMap 的主体，存储键值对节点。</p><p><strong>链表</strong>：解决哈希冲突的主要方式（Java 8 之前）。</p><p><strong>红黑树</strong>：当单个桶中的元素超过阈值（默认 8），链表转换为红黑树，提高查询效率（Java 8 起）。</p><p><img src="'+i+'" alt="af1ea7d9965ada42d97f8d10c5e879b9"></p><h3 id="核心流程" tabindex="-1"><a class="header-anchor" href="#核心流程"><span>核心流程</span></a></h3><h4 id="存储-put" tabindex="-1"><a class="header-anchor" href="#存储-put"><span>存储（put）</span></a></h4><blockquote><ol><li><p>计算键的 <code>hash</code> 值。</p></li><li><p>根据 <code>hash % table.length</code> 定位数组索引。</p></li><li><p>如果该位置为空，直接插入； 如果不为空，遍历链表或树：</p><ul><li><p>key 已存在：更新 value；</p></li><li><p>key 不存在：添加新节点，必要时树化。</p></li></ul></li></ol></blockquote><ul><li>put方法流程图。</li></ul><p><img src="'+n+'" alt="73496942ccf51c9890d23ba12f5d4932"></p><h4 id="查询-get" tabindex="-1"><a class="header-anchor" href="#查询-get"><span>查询（get）</span></a></h4><ol><li><p>计算 <code>hash</code>。</p></li><li><p>定位数组索引。</p></li><li><p>根据 key 遍历链表或红黑树，匹配相同 key。</p></li></ol><h3 id="负载因子" tabindex="-1"><a class="header-anchor" href="#负载因子"><span>负载因子</span></a></h3><ul><li>默认负载因子：0.75</li><li>当元素数量 &gt; 阈值（capacity × load factor）时，数组扩容为原来的 2 倍，重新哈希分布所有节点。</li></ul><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点"><span>特点</span></a></h3><ul><li>key 允许为 null（最多一个）。</li><li>非线程安全（需使用 <code>Collections.synchronizedMap</code> 或 <code>ConcurrentHashMap</code>）。</li></ul><h2 id="_2-jvm内存分哪几个区-每个区的作用是什么" tabindex="-1"><a class="header-anchor" href="#_2-jvm内存分哪几个区-每个区的作用是什么"><span>2. JVM内存分哪几个区，每个区的作用是什么</span></a></h2><table><thead><tr><th>名称</th><th>是否线程私有</th><th>主要作用说明</th></tr></thead><tbody><tr><td><strong>方法区（Method Area）</strong></td><td>否（线程共享）</td><td>存放类的元信息（类结构、常量池、静态变量、JIT 编译代码等）。Java 8 后为<strong>元空间</strong>，使用本地内存。</td></tr><tr><td><strong>堆内存（Heap）</strong></td><td>否（线程共享）</td><td>存储<strong>所有对象实例</strong>和数组，是 GC 的主要区域。</td></tr><tr><td><strong>Java 栈内存（JVM Stack）</strong></td><td>是（线程私有）</td><td>方法调用时创建栈帧，保存局部变量、操作数栈、返回值等。</td></tr><tr><td><strong>Native 栈内存（Native Method Stack）</strong></td><td>是（线程私有）</td><td>用于支持 Native 方法的调用（如 JNI）。</td></tr><tr><td><strong>程序计数器（Program Counter）</strong></td><td>是（线程私有）</td><td>指示当前线程所执行的字节码行号地址，类似“行号指针”。</td></tr></tbody></table><p><img src="'+a+`" alt="59a1cd98b61671b569e9817708de262a"></p><h2 id="_3-java中垃圾回收-gc-的方式有哪些" tabindex="-1"><a class="header-anchor" href="#_3-java中垃圾回收-gc-的方式有哪些"><span>3. Java中垃圾回收（GC）的方式有哪些</span></a></h2><h3 id="按回收算法分类" tabindex="-1"><a class="header-anchor" href="#按回收算法分类"><span>按回收算法分类</span></a></h3><table><thead><tr><th>算法名称</th><th>原理简介</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>标记-清除</strong> (Mark-Sweep)</td><td>标记所有存活对象 → 清除未标记对象</td><td>实现简单，无需复制，节省空间</td><td>会产生<strong>内存碎片</strong>，回收速度慢，分配大对象可能失败</td><td>老年代（早期使用）</td></tr><tr><td><strong>复制算法</strong> (Copying)</td><td>存活对象复制到另一块区域，清空原区域</td><td><strong>无碎片</strong>，分配连续内存，回收快</td><td>空间浪费大（只能用一半），对象存活率高时，复制开销大</td><td>新生代（对象生命周期短）</td></tr><tr><td><strong>标记-整理</strong> (Mark-Compact)</td><td>标记存活对象 → 整理到一端 → 清理无效对象</td><td>无碎片，不浪费内存，支持大对象分配</td><td>移动对象成本高，整理耗时</td><td>老年代（对象存活率高）</td></tr><tr><td><strong>分代收集</strong> (Generational)</td><td>将内存划分为新生代、老年代，分别使用不同算法（如复制 + 标记整理）</td><td>综合多种算法优点，高效适应不同生命周期的对象</td><td>实现复杂，分代调整策略需要调优</td><td>JVM 默认策略</td></tr></tbody></table><h3 id="按垃圾回收器名称分类-hotspot-jvm-常见-gc" tabindex="-1"><a class="header-anchor" href="#按垃圾回收器名称分类-hotspot-jvm-常见-gc"><span>按垃圾回收器名称分类（HotSpot JVM 常见 GC）</span></a></h3><table><thead><tr><th>回收器</th><th>适用区域</th><th>特点</th></tr></thead><tbody><tr><td><strong>Serial</strong></td><td>新生代（复制算法）</td><td>单线程，适用于小内存、单核。</td></tr><tr><td><strong>ParNew</strong></td><td>新生代（复制算法）</td><td>多线程版 Serial，可与 CMS 搭配使用。</td></tr><tr><td><strong>Parallel Scavenge（吞吐量优先）</strong></td><td>新生代（复制算法）</td><td>多线程，追求高吞吐量，配合 Parallel Old 使用。</td></tr><tr><td><strong>Parallel Old</strong></td><td>老年代（标记-整理）</td><td>Parallel Scavenge 的老年代回收器。</td></tr><tr><td><strong>CMS（Concurrent Mark Sweep）</strong></td><td>老年代（标记-清除）</td><td>并发低停顿，适合响应时间敏感应用；有碎片问题。</td></tr><tr><td><strong>G1（Garbage First）</strong></td><td>新生代+老年代（分区回收）</td><td>支持并发、低停顿、可预测，适合大内存。</td></tr><tr><td><strong>ZGC（Java 11+）</strong></td><td>全区域并发回收</td><td>极低停顿（&lt;10ms），支持大内存（TB 级）。</td></tr><tr><td><strong>Shenandoah（Java 12+）</strong></td><td>全区域并发回收</td><td>类似 ZGC，适合低延迟场景。</td></tr></tbody></table><h2 id="_4-如何判断一个对象是否存活-或者gc对象的判定方法" tabindex="-1"><a class="header-anchor" href="#_4-如何判断一个对象是否存活-或者gc对象的判定方法"><span>4. 如何判断一个对象是否存活(或者GC对象的判定方法)</span></a></h2><h3 id="引用计数法-reference-counting-已淘汰" tabindex="-1"><a class="header-anchor" href="#引用计数法-reference-counting-已淘汰"><span>引用计数法（Reference Counting，已淘汰）</span></a></h3><h4 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理：</span></a></h4><ul><li>每个对象维护一个<strong>引用计数器</strong>，被引用一次计数加一，引用断开减一；</li><li>计数为 0 的对象会被判定为垃圾。</li></ul><h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点：</span></a></h4><ul><li>无法处理<strong>循环引用</strong>，比如两个对象互相引用但已无外部引用，仍然无法被回收；</li><li>因此被 <strong>HotSpot JVM</strong> 等主流虚拟机淘汰。</li></ul><h3 id="可达性分析算法-reachability-analysis-主流" tabindex="-1"><a class="header-anchor" href="#可达性分析算法-reachability-analysis-主流"><span>可达性分析算法（Reachability Analysis，主流）</span></a></h3><h4 id="原理-1" tabindex="-1"><a class="header-anchor" href="#原理-1"><span>原理：</span></a></h4><ul><li>从一组称为 <strong>GC Roots</strong> 的对象出发，向下搜索，能连通的对象为<strong>可达对象</strong>，否则为垃圾；</li><li><strong>不可达 ≠ 立即死亡</strong>，还可能进入 “<strong>四次判死</strong>” 机制。</li></ul><h4 id="gc-roots-包括" tabindex="-1"><a class="header-anchor" href="#gc-roots-包括"><span>GC Roots 包括：</span></a></h4><ul><li>虚拟机栈中的<strong>引用变量</strong>（方法栈帧中的局部变量表）</li><li>方法区中的<strong>类静态属性</strong></li><li>方法区中的<strong>常量引用</strong></li><li>本地方法栈中 JNI 引用（Native 方法）</li></ul><h4 id="对象-真正死亡-前的判断过程" tabindex="-1"><a class="header-anchor" href="#对象-真正死亡-前的判断过程"><span>对象“真正死亡”前的判断过程</span></a></h4><ul><li>对于不可达对象，还要经历如下判定才会被彻底GC：</li></ul><table><thead><tr><th>判定阶段</th><th>条件</th><th>说明</th></tr></thead><tbody><tr><td><strong>第一次判定</strong></td><td>是否重写 <code>finalize()</code> 方法</td><td>如果没有，立即判定为垃圾</td></tr><tr><td><strong>第二次判定</strong></td><td>执行 <code>finalize()</code>，是否重新建立引用链</td><td>有引用则“复活”；否则进入下一轮 GC</td></tr><tr><td><strong>最终回收</strong></td><td>finalize 后仍不可达</td><td>判定死亡，GC 回收</td></tr></tbody></table><blockquote><p><strong>finalize()</strong>：</p><ul><li>在对象被 GC 前做一些<strong>资源释放</strong>、<strong>日志记录</strong>等清理工作；</li><li>允许对象“<strong>自救</strong>”，即在 <code>finalize()</code> 中重新让自己变为可达对象（比如把 <code>this</code> 赋值给某个静态变量）。</li><li>GC 判定对象“不可达”后，若重写了 <code>finalize()</code>： <ul><li>会将该对象放入 <code>F-Queue</code>（Finalizer Reference Queue）；</li><li>由一个 JVM 内部线程（Finalizer Thread）异步调用其 <code>finalize()</code> 方法；</li><li>如果在方法中重新建立引用链，GC 会“放你一马”；</li><li>每个对象的 <code>finalize()</code> <strong>最多只会被调用一次</strong>。</li></ul></li></ul></blockquote><h2 id="_5-什么情况下会产生stackoverflowerror-栈溢出-和outofmemoryerror-堆溢出-怎么排查" tabindex="-1"><a class="header-anchor" href="#_5-什么情况下会产生stackoverflowerror-栈溢出-和outofmemoryerror-堆溢出-怎么排查"><span>5. 什么情况下会产生StackOverflowError（栈溢出）和OutOfMemoryError（堆溢出）？怎么排查？</span></a></h2><h3 id="stackoverflowerror-栈溢出" tabindex="-1"><a class="header-anchor" href="#stackoverflowerror-栈溢出"><span>StackOverflowError（栈溢出）</span></a></h3><h4 id="常见原因" tabindex="-1"><a class="header-anchor" href="#常见原因"><span>常见原因</span></a></h4><ol><li><p>递归调用过深（最常见）。</p></li><li><p><strong>方法调用层级过深</strong>，每个方法占用栈帧过多；</p></li><li><p>设置的 <strong>栈大小过小</strong>（<code>-Xss</code> 参数）；</p></li></ol><h4 id="排查" tabindex="-1"><a class="header-anchor" href="#排查"><span>排查</span></a></h4><p><strong>查看异常堆栈信息</strong>：函数调用是否死递归；</p><p><strong>调试终止条件</strong>：确认递归有明确返回条件；</p><p><strong>调整 JVM 参数</strong>（如增大线程栈大小）：<code>-Xss512k（默认） → -Xss1m</code></p><h3 id="outofmemoryerror-堆溢出" tabindex="-1"><a class="header-anchor" href="#outofmemoryerror-堆溢出"><span>OutOfMemoryError（堆溢出）</span></a></h3><h4 id="常见原因-1" tabindex="-1"><a class="header-anchor" href="#常见原因-1"><span>常见原因</span></a></h4><ol><li><p><strong>创建了过多对象，未释放引用</strong>；</p></li><li><p><strong>大集合或缓存未清理</strong>（如 List 不断添加元素）；</p></li><li><p><strong>内存泄漏</strong>：对象应该被回收却被意外引用；</p></li><li><p><strong>JVM 堆内存设置太小</strong>（默认最大内存不足）；</p></li><li><p><strong>线程数过多间接耗尽堆空间</strong>；</p></li><li><p><strong>某些场景下 String.intern() 导致元空间爆满</strong>（老版本 PermGen）；</p></li></ol><h4 id="排查方法" tabindex="-1"><a class="header-anchor" href="#排查方法"><span>排查方法</span></a></h4><ul><li><p><strong>查看 GC 日志/内存监控</strong>：</p><ul><li>使用 <code>-XX:+PrintGCDetails -Xloggc:gc.log</code>；</li><li>或 JVisualVM、MAT、JProfiler 工具；</li></ul></li><li><p><strong>定位内存泄漏对象</strong>：</p><ul><li>使用 MAT 工具分析 <code>.hprof</code> 文件；</li><li>查找 “GC Roots” 强引用链；</li></ul></li><li><p><strong>调整 JVM 参数</strong>（如增大堆内存）：<code>-Xms512m -Xmx1024m</code></p></li></ul><h2 id="_6-什么是线程池-有什么类型-如何创建" tabindex="-1"><a class="header-anchor" href="#_6-什么是线程池-有什么类型-如何创建"><span>6. 什么是线程池，有什么类型，如何创建？</span></a></h2><h3 id="什么是线程池" tabindex="-1"><a class="header-anchor" href="#什么是线程池"><span>什么是线程池？</span></a></h3><p><strong>线程池（Thread Pool）<strong>是一种</strong>复用线程资源</strong>的机制，用于限制和管理线程的创建与销毁，避免频繁创建/销毁线程带来的性能损耗。</p><blockquote><p>本质上就是一个<strong>线程的容器</strong>，可以反复使用已有线程执行任务。</p></blockquote><h3 id="线程池的作用" tabindex="-1"><a class="header-anchor" href="#线程池的作用"><span>线程池的作用？</span></a></h3><table><thead><tr><th>优点</th><th>说明</th></tr></thead><tbody><tr><td>降低资源开销</td><td>复用已有线程，避免频繁创建销毁线程</td></tr><tr><td>提高响应速度</td><td>提交任务即可立即执行，不需等待新线程创建</td></tr><tr><td>提供线程管理机制</td><td>控制最大并发数、超时策略、任务排队策略等</td></tr><tr><td>提高系统稳定性</td><td>防止无限制创建线程导致 OOM 或系统崩溃</td></tr></tbody></table><h3 id="线程池的类型" tabindex="-1"><a class="header-anchor" href="#线程池的类型"><span>线程池的类型</span></a></h3><table><thead><tr><th>线程池类型</th><th>创建方式</th><th>特点说明</th></tr></thead><tbody><tr><td><strong>固定大小线程池</strong></td><td><code>Executors.newFixedThreadPool(n)</code></td><td>线程数固定，适合负载稳定的场景；超出部分排队执行</td></tr><tr><td><strong>单线程线程池</strong></td><td><code>Executors.newSingleThreadExecutor()</code></td><td>只有一个线程，顺序执行任务FIFO，适用于顺序任务处理</td></tr><tr><td><strong>缓存线程池（无限大）</strong></td><td><code>Executors.newCachedThreadPool()</code></td><td>空闲线程可复用，线程可无限增长（Integer.MAX_VALUE），适合任务密集但执行快的场景</td></tr><tr><td><strong>定时任务线程池</strong></td><td><code>Executors.newScheduledThreadPool(n)</code></td><td>支持定时任务或周期任务执行</td></tr><tr><td><strong>工作窃取线程池（Java 8+）</strong></td><td><code>Executors.newWorkStealingPool()</code></td><td>利用多核 CPU，自动进行任务分配与负载均衡</td></tr></tbody></table><h3 id="自定义线程池" tabindex="-1"><a class="header-anchor" href="#自定义线程池"><span>自定义线程池</span></a></h3><p>通过 <code>ThreadPoolExecutor</code> 类构建，更灵活：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">ThreadPoolExecutor</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> executor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> ThreadPoolExecutor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    corePoolSize</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">         // 核心线程数</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    maximumPoolSize</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">      // 最大线程数</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    keepAliveTime</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        // 空闲线程存活时间</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    TimeUnit</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">SECONDS</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">     // 时间单位</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> LinkedBlockingQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;&gt;(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">100</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">),</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 阻塞队列（任务等待区）</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    Executors</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">defaultThreadFactory</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(),</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 线程工厂</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ThreadPoolExecutor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">AbortPolicy</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 拒绝策略</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>拒绝策略说明：</p><table><thead><tr><th>策略名</th><th>说明</th></tr></thead><tbody><tr><td><code>AbortPolicy</code>（默认）</td><td>抛异常拒绝任务</td></tr><tr><td><code>CallerRunsPolicy</code></td><td>由调用者线程执行任务（降级）</td></tr><tr><td><code>DiscardPolicy</code></td><td>直接丢弃任务</td></tr><tr><td><code>DiscardOldestPolicy</code></td><td>丢弃队列中最老的任务，尝试提交新任务</td></tr></tbody></table><h3 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span>注意事项</span></a></h3><ul><li><p><strong>不要直接使用 <code>Executors</code> 创建线程池</strong>（原因：默认策略不安全，易OOM），推荐用 <code>ThreadPoolExecutor</code> 明确参数；</p></li><li><p>对于 Web 服务类系统，建议根据 <strong>CPU核心数</strong> 配置线程数（如 <code>CPU核数 * 2</code>）；</p></li><li><p>配合监控工具（如 <code>JVisualVM</code>）观察线程池状态，有助于调优。</p></li></ul><h2 id="_7-为什么要使用线程" tabindex="-1"><a class="header-anchor" href="#_7-为什么要使用线程"><span>7. 为什么要使用线程</span></a></h2><table><thead><tr><th>原因</th><th>解释</th></tr></thead><tbody><tr><td><strong>1. 降低资源开销</strong></td><td>线程复用，避免频繁创建与销毁线程带来的<strong>性能开销</strong>。</td></tr><tr><td><strong>2. 提高响应速度</strong></td><td>任务提交后可以直接复用已有线程，<strong>立即执行</strong>，无需等待线程创建。</td></tr><tr><td><strong>3. 控制最大并发量</strong></td><td>限制同时运行的线程数，<strong>防止系统资源耗尽</strong>导致崩溃。</td></tr><tr><td><strong>4. 实现任务排队与调度</strong></td><td>内部维护<strong>任务队列</strong>，支持任务<strong>排队、延迟、定时、周期</strong>执行。</td></tr><tr><td><strong>5. 提升系统稳定性和可维护性</strong></td><td>通过统一的线程管理机制，更易于<strong>监控、调优和故障恢复</strong>。</td></tr></tbody></table>`,72)]))}const g=s(o,[["render",l]]),k=JSON.parse('{"path":"/studyNotes/frbi5y1d/","title":"面试题-Java高级","lang":"zh-CN","frontmatter":{"title":"面试题-Java高级","createTime":"2025/07/03 02:39:45","permalink":"/studyNotes/frbi5y1d/"},"readingTime":{"minutes":8.41,"words":2522},"git":{"updatedTime":1749436129000,"contributors":[{"name":"Lang","username":"Lang","email":"914551901@qq.com","commits":6,"avatar":"https://avatars.githubusercontent.com/Lang?v=4","url":"https://github.com/Lang"}]},"filePathRelative":"notes/学习笔记/八股文/面试题-Java高级.md","headers":[]}');export{g as comp,k as data};
